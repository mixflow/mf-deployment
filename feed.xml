<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://www.mix-flow.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.mix-flow.com/" rel="alternate" type="text/html" /><updated>2023-03-15T19:19:21+08:00</updated><id>https://www.mix-flow.com/feed.xml</id><title type="html">MixFlow</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">A Glimpse into ChatGPT by A Conversation with ChatGPT - Machine Learning Strategy</title><link href="https://www.mix-flow.com/machine-learning-strategy/2023/02/13/A-Glimpse-into-ChatGPT-by-A-Conversation-with-ChatGPT.html" rel="alternate" type="text/html" title="A Glimpse into ChatGPT by A Conversation with ChatGPT - Machine Learning Strategy" /><published>2023-02-13T12:38:14+08:00</published><updated>2023-02-13T12:38:14+08:00</updated><id>https://www.mix-flow.com/machine-learning-strategy/2023/02/13/A-Glimpse-into-ChatGPT-by-A-Conversation-with-ChatGPT</id><content type="html" xml:base="https://www.mix-flow.com/machine-learning-strategy/2023/02/13/A-Glimpse-into-ChatGPT-by-A-Conversation-with-ChatGPT.html"><![CDATA[<blockquote>
<p>The “Machine Learning Strategy” series is a collection of articles on
the subjects of Machine Learning, Neural Networks and Artificial
Intelligence. In this series, I will share my personal experiences and
insights as I learn and understand these topics. The articles will cover
aspects such as the tools and techniques used in ML, the programming
concepts involved, and even the psychological impact of human
interaction with AI.</p>
<p>The aim is to provide both a practial and theoretical understanding
of Machine Learning. This includes exploring the applications of ML, as
well as its underlying implementation and limitations, along with
pontential areas for improvement. Both the ways in which Machine
Learning can be utilized and the potential advancement of the technology
itself Hopefully, I would offer both the application of Machine
Learning, and Machine Learning itself underlying implementation and
limits with potential improvements. This is two way of the “strategy”, a
way about usage and a way about AI itself.</p>
</blockquote>
<p>ChatGPT almost had gone viral once it released. One month ago, I
encounter the ChatGPT and check whether its ability is good as mentioned
which is a better and smarter AI.</p>
<p>Compare to the API to access GPT-3, it’s a easier and smarter way to
just have a dialoge with the AI like ordinary IM software which has no
preset after account registration.</p>
<p>I heard about ChatGPT and GPT-3, but not very much technique related.
So I decided to give a interview and let ChatGPT itself explain and
educate. <!--more--></p>
<h1 id="is-it-based-on-gpt-3---overview-of-chatgpt-model">Is it based on
GPT-3? - Overview of ChatGPT Model</h1>
<p>About years ago, I heard GPT-3 from some which is also developed by
OpenAI. I had been not sure about whether the ChatGPT is based on GPT-3
or another totally different approach. So I just start with the question
“is ChatGPT based on GPT-3?”. It confirms that the archeitecture and
trainning data are total unique from the GPT-3.</p>
<p>It’s also a deep neural network model which doesn’t have a specify
name, but it belongs to a larger system called “Assistant”. According to
the reply from ChatGPT, the “Assistant” system can do a bunch of
different types of tasks, includes the language model which exactly is
the ChatGPT and speech recognition and image processing and more.</p>
<h1 id="details-of-the-language-model">Details of The Language
Model</h1>
<p>Language model would process and generate the text. I also asked
ChatGPT to cover more techinial information.</p>
<p>Basicly it’s a variant of the <strong><em>Transformer</em></strong>
architecture that is a neural network for tasks of
<strong><em>NLP</em></strong>(<strong><em>natural language
processing</em></strong>). The process is literally to <strong>predict
the next word in a sequence, given the previous words</strong>, which is
called as <strong><em>Masked Language Modeling</em></strong>.</p>
<p>ChatGPT is also based on <strong><em>self-attention</em></strong>
which allows the model to weight the importance of different input words
of a given sequence of text.</p>
<h2 id="comparison-to-long-short-term-memory-model">Comparison to Long
Short-term Memory Model</h2>
<p>After read the explaination from ChatGPT. I realized that it is quite
similar to <strong><em>LSTM</em></strong>(<strong><em>Long Short-term
Memory</em></strong>) model and discussed this topic in serval
questions.</p>
<p>Main difference is the implementation to preserve the input
information. LSTM use memory cell instead ChatGPT use
<strong><em>self-attention</em></strong></p>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/LSTM_Cell.svg/450px-LSTM_Cell.svg.png"
alt="Long Short-term Memory cell can process data sequentially and keep its hidden state through time. From wikipedia" />
<figcaption aria-hidden="true">Long Short-term Memory cell can process
data sequentially and keep its hidden state through time. From <a
href="https://en.wikipedia.org/wiki/Long_short-term_memory">wikipedia</a></figcaption>
</figure>
<p>self-attention calculate the weight of the the importance of each
word in the input sequence. I wouldn’t show the technique which I
thought was not intuitive, You can also search another term “Q,K,V”
which are the vectors to use in the calculation and excatly the
self-attention part.</p>
<h1 id="languages---the-training-data">Languages - The Training
data</h1>
<p>// the main language is English // train multiple languages at the
same time</p>]]></content><author><name></name></author><category term="Machine-Learning-Strategy" /><category term="ML" /><category term="Machine Learning" /><category term="AI" /><category term="Artificial Intelligence" /><category term="Neural Network" /><category term="NLP" /><category term="Natural Language Processing" /><category term="ChatGPT" /><category term="OpenAI" /><category term="GPT" /><category term="Generative Pre-trained Transformer" /><category term="GPT-3" /><category term="LSTM" /><category term="Long Short-Term Memory Model" /><category term="Machine Learning Strategy" /><category term="Machine Learning Strategy series" /><summary type="html"><![CDATA[The “Machine Learning Strategy” series is a collection of articles on the subjects of Machine Learning, Neural Networks and Artificial Intelligence. In this series, I will share my personal experiences and insights as I learn and understand these topics. The articles will cover aspects such as the tools and techniques used in ML, the programming concepts involved, and even the psychological impact of human interaction with AI. The aim is to provide both a practial and theoretical understanding of Machine Learning. This includes exploring the applications of ML, as well as its underlying implementation and limitations, along with pontential areas for improvement. Both the ways in which Machine Learning can be utilized and the potential advancement of the technology itself Hopefully, I would offer both the application of Machine Learning, and Machine Learning itself underlying implementation and limits with potential improvements. This is two way of the “strategy”, a way about usage and a way about AI itself. ChatGPT almost had gone viral once it released. One month ago, I encounter the ChatGPT and check whether its ability is good as mentioned which is a better and smarter AI. Compare to the API to access GPT-3, it’s a easier and smarter way to just have a dialoge with the AI like ordinary IM software which has no preset after account registration. I heard about ChatGPT and GPT-3, but not very much technique related. So I decided to give a interview and let ChatGPT itself explain and educate.]]></summary></entry><entry><title type="html">UE5 Lumen Realtime GI Project - Room in the Desert</title><link href="https://www.mix-flow.com/2021/11/19/UE5-Lumen-Realtime-GI-Project-Room-in-the-desert.html" rel="alternate" type="text/html" title="UE5 Lumen Realtime GI Project - Room in the Desert" /><published>2021-11-19T03:45:26+08:00</published><updated>2021-11-19T03:45:26+08:00</updated><id>https://www.mix-flow.com/2021/11/19/UE5-Lumen-Realtime-GI-Project-Room-in-the-desert</id><content type="html" xml:base="https://www.mix-flow.com/2021/11/19/UE5-Lumen-Realtime-GI-Project-Room-in-the-desert.html"><![CDATA[<p>It’s <code>Unreal Engine 5</code> project, which I try the new
features, and It would be a some kind of whole project that can be
shown.</p>
<p>In the new coming UE5, the most exciting feature could be
<code>Lumen</code>, which is the new light system that provides the
real-time globe illumination even without ray tracing hardware(GPU). In
other words, graphic/video quality is close to real life, and could
apply to video game in real-time.</p>
<!-- # [WIP] Showcase
I'm working the project right now. More images come later. -->
<h1 id="progress">Progress</h1>
<p>During this UE5 project and the blog, I would record the main steps
of my work progress.</p>
<h2 id="quick-lighting-test">1. Quick Lighting Test</h2>
<figure>
<video src="/assets/images/2021-ue5-lumen/quick-lighting-interior.webm"
controls=""><a
href="/assets/images/2021-ue5-lumen/quick-lighting-interior.webm">Interior
lighting through time</a></video>
<figcaption aria-hidden="true">Interior lighting through
time</figcaption>
</figure>
<figure>
<video src="/assets/images/2021-ue5-lumen/quick-lighting-exterior.webm"
controls=""><a
href="/assets/images/2021-ue5-lumen/quick-lighting-exterior.webm">Exterior
lighting through time</a></video>
<figcaption aria-hidden="true">Exterior lighting through
time</figcaption>
</figure>
<!--more-->
<p>The scene is amazing at the time of twilight! Although there are some
glitches which I will tweak later.</p>
<p>I build a small area of desert before which is used to check exterior
lighting, And reuse a part of room model which is created in blender
before to check interior light.</p>
<p>Those aren’t finished objects, just give me a glimpse of light
condition, a quick overview.</p>]]></content><author><name></name></author><category term="UE5" /><category term="unreal engine 5" /><category term="PBR" /><category term="lumen" /><category term="GI" /><category term="real-time" /><summary type="html"><![CDATA[It’s Unreal Engine 5 project, which I try the new features, and It would be a some kind of whole project that can be shown. In the new coming UE5, the most exciting feature could be Lumen, which is the new light system that provides the real-time globe illumination even without ray tracing hardware(GPU). In other words, graphic/video quality is close to real life, and could apply to video game in real-time. Progress During this UE5 project and the blog, I would record the main steps of my work progress. 1. Quick Lighting Test Interior lighting through time Interior lighting through time Exterior lighting through time Exterior lighting through time]]></summary></entry><entry xml:lang="zh"><title type="html">照片级写实的秘诀 The Secret Ingredient to Photorealism</title><link href="https://www.mix-flow.com/2017/08/27/The-Secret-Ingredient-to-Photorealism.html" rel="alternate" type="text/html" title="照片级写实的秘诀 The Secret Ingredient to Photorealism" /><published>2017-08-27T05:33:47+08:00</published><updated>2017-08-27T05:33:47+08:00</updated><id>https://www.mix-flow.com/2017/08/27/The-Secret-Ingredient-to-Photorealism</id><content type="html" xml:base="https://www.mix-flow.com/2017/08/27/The-Secret-Ingredient-to-Photorealism.html"><![CDATA[<blockquote>
<p>[2020-01 Update] 于2018年10月，Blender 2.8正式版发布，默认color
management即本文提及的<code>Flimic</code>, 应该就是把其整合进
Blender，本文关于 Flimic 使用方法依旧有用。</p>
</blockquote>
<p>我曾经在我的文章 <a
href="/works/blender/cycles/2017/04/02/blender-cycles-render-donuts.html">Blender
Cycles渲染作品 面包圈</a> 提到发现一个改进方法，能够大幅提高渲染
<em>render</em> 效果。</p>
<p>本文我会通过上面提及的面包圈作品作为实例，来谈论原生blender
<code>dynamic range 动态范围</code>的限制。
以及突破限制的方式，即<code>Filmic Blender</code>插件，最终能带来不可思议的照片级渲染效果。</p>
<figure>
<img src="/assets/images/2017-BlenderFilmic/filmic-before&amp;after.jpg"
alt="渲染效果对比 右边改进的作品 提升效果明显" />
<figcaption aria-hidden="true">渲染效果对比 右边改进的作品
提升效果明显</figcaption>
</figure>
<p>这个改进方法我是从blenderguru的一个非常棒的<a
href="https://youtu.be/m9AT7H4GGrA">youtube教程视频 The Secret
Ingredient to Photorealism</a>学到的。
我极力推荐观看。我文章基本就是根据视频整理得出，额外加些我的内容。</p>
<p>另外本文基于blender编写，但是里面相当多的内容并不局限于blender，甚至<code>Filmic</code>的幕后实现也是基于其他领域的成果（下面正文<!-- TODO link to the section-->我会介绍）。
所以如果你使用其他CG或者渲染软件，以及别的相关领域也建议了解下。
<!--more--></p>
<p>比如虚幻4 UE4游戏引擎在4.15版本的时候也有类似的新特性 <a href="#fn1"
class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>。</p>
<h2 id="what-is-dynamic-range">What is Dynamic Range</h2>
<p>首先从拍照来引入，相机（或手机）取景会显得过亮或者过暗，我们经常会选取图像的某一处作为“曝光点”，
然后镜头会以我们选择的“曝光点”作为 中间灰度值 <em>middle grey</em>
自动调节。</p>
<p>在一些光照复杂的情况，比如烈日户外，我需要拍摄一个阴影处的物体，我们选择暗处作为曝光点，
可能外部天空背景就会显得过亮。当我选择天空作为曝光点，暗处又会显得很暗，甚至一团黑完全看不到东西。</p>
<p>这两种纠结的情况会发生，就是因为相机曝光范围有限制，这个限制范围就是
<code>dynamic range 动态范围</code> 。</p>
<!-- ![Dynamic Range. 图片来源blenderguru.com](){class=b-lazy data-src=/assets/images/2017-BlenderFilmic/dynamic-range.png} -->
<figure>
<img src="/assets/images/2017-BlenderFilmic/dynamic-range.png"
alt="Dynamic Range. 图片来源blenderguru.com" />
<figcaption aria-hidden="true">Dynamic Range.
图片来源blenderguru.com</figcaption>
</figure>
<p>超出 <code>dynamic range</code> 的部分被称为 <code>clipping</code>
，过暗以至于完全黑色的被称作 <code>black clipping</code> ，
相反的过亮完全变白的的被称作 <code>white clipping</code> 。</p>
<!-- ![__`Clipping`__ 下图红色部分即 `white clipping` 部分(高光)，
另外图中黑色冲压（图中间的柱体）也有 `black clipping` 的部分 图片来源 [wikipedia](https://en.wikipedia.org/wiki/Clipping_(photography)) ](){
    class=b-lazy
    data-src=https://upload.wikimedia.org/wikipedia/commons/7/7b/Blown-out_highlights.jpg
} -->
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/7/7b/Blown-out_highlights.jpg"
alt="Clipping 下图红色部分即 white clipping 部分(高光)， 另外图中黑色冲压（图中间的柱体）也有 black clipping 的部分 图片来源 wikipedia" />
<figcaption aria-hidden="true"><strong><code>Clipping</code></strong>
下图红色部分即 <code>white clipping</code> 部分(高光)，
另外图中黑色冲压（图中间的柱体）也有 <code>black clipping</code> 的部分
图片来源 <a
href="https://en.wikipedia.org/wiki/Clipping_(photography)">wikipedia</a></figcaption>
</figure>
<p><code>clipping</code> 的部分是超出了感光器材的
<code>dynamic range</code> 产生，但并不是所有情况都是缺陷。有些情况下，
有些地方就因该是高光，比如光滑金属的反光的部分；或者完全的暗部，现实光照就是不足以照亮的角落
。但有时不能接受， 比如我的面包圈之前的效果，其中一处在偏左白色盘子存在
<code>white clipping</code> 问题，
以至无法看出盘子中间是凹的（对比右图）。</p>
<p>笼统说 <code>dynamic range</code> 越宽，效果越好。衡量其范围的单位为
<code>f-stops</code>:</p>
<!-- ![不同的成像设备以及人眼的f-stops。 图片来源blenderguru.com](){
    class=b-lazy
    data-src=/assets/images/2017-BlenderFilmic/f-stops.png
} -->
<figure>
<img src="/assets/images/2017-BlenderFilmic/f-stops.png"
alt="不同的成像设备以及人眼的f-stops。 图片来源blenderguru.com" />
<figcaption aria-hidden="true">不同的成像设备以及人眼的f-stops。
图片来源blenderguru.com</figcaption>
</figure>
<p>上述图中，最好的是人眼，达到了
<code>20 f-stops</code>。最差的便携相机都有 <code>10 f-stops</code>。
而blender，仅有 <code>8 f-stops</code>，甚至连最差的便携相机都不如。</p>
<h2 id="dynamic-range-如何影响渲染结果">Dynamic Range
如何影响渲染结果</h2>
<p>前文一直借用摄像领域的介绍，现在回到blender，谈谈
<code>dynamic range</code> 如何影响渲染的结果。</p>
<!-- ![左边盘子已经出现 `white clipping` 但是整个场景很多依旧感觉很暗](){
    class=b-lazy
    data-src=/assets/images/2017-BlenderFilmic/sRGB_camera_0.png
} -->
<figure>
<img src="assets/images/2017-BlenderFilmic/sRGB_camera_0.png"
alt="左边盘子已经出现 white clipping 但是整个场景很多依旧感觉很暗" />
<figcaption aria-hidden="true">左边盘子已经出现
<code>white clipping</code> 但是整个场景很多依旧感觉很暗</figcaption>
</figure>
<p>在左边盘子以及桌面出现大量的 <code>white clipping</code> 的时候，
光源不能继续提高亮度了，但是场景有的部分依旧感觉很暗，比如右边
巧克力面包圈下面的阴影。</p>
<blockquote>
<p>blenderguru的教程，其使用的例子也是类似的情况，而且其光照条件更为苛刻。
是在一个基本封闭的室内，只有一扇窗户有采光，当透过这扇窗的直射光找到
其室内的桌子并出现 <code>white clipping</code>
的时候，整个房间别处依旧很暗。
而这间房子，即作者的房间，作者提供一张现实的照片，现实里并不会如此暗，
整个房间还是很明亮的。</p>
</blockquote>
<p>这时，有些人会采取一些“作弊”方式来解决，比如添加额外的光源来模拟增强反射光<code>bounce lighting</code>，
或者增强 <code>sky light</code> 来增加室内光线。</p>
<p>但仔细想想 <strong>这种做法没有意义！</strong>
我们现实世界并不需要“作弊”。</p>
<p>Blender存在这些问题是由于狭窄的 <code>dynamic range</code> 限制:</p>
<ul>
<li>场景过暗，是由于光源的反射光不足。</li>
<li>光源的反射光不足，是由于光源亮度不够。</li>
<li>光源的亮度不够，是由于光源已经很刺眼了。</li>
<li>光源完全刺眼，是由于 <code>dynamic range</code> 太窄只有
<code>8 f-stops</code>。</li>
</ul>
<p>如果我们能够提高
<code>dynamic range</code>，我们就可以提高光源亮度，这样反射光就会增强，
最终我们就能得到完美的光照效果，而不需要额外的工作量。</p>
<h2 id="blender-dynamic-range-有限的原因">Blender Dynamic Range
有限的原因</h2>
<p>幸运的是blender的<code>渲染器 renderer</code> 并不存在缺陷，别的
<code>renderer</code> 也有可能出现该问题。
真正问题根源是原生blender使用的
<code>色彩管理配置 Color Management Configuration</code>。</p>
<p><code>renderer</code>
和相机，存储图像数据都是数字格式，当将数字数据显示为图像的时候，是
需要经过转化处理的，就是 <code>色彩转化 color transform</code>。</p>
<p><strong>问题的根源</strong> 是blender使用了
<strong><code>sRGB</code></strong> color transform。<code>sRGB</code>
是设计来模拟 CRT显示器 的显示效果。
而这本意不是用来渲染的，永远不应该拿来渲染。</p>
<h2 id="解决方式-filimic-blender">解决方式 Filimic Blender</h2>
<p>我们只需要将原生的blender的<code>sRGB</code> 改为名为
<code>Filmic Blender</code> 的 <code>color management</code>。</p>
<p><a href="https://sobotka.github.io/filmic-blender/">Filmic
Blender</a>是由 Troy Sobotka 编写一套 color management。类似于ACES<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a> 。<code>Filmic Blender</code> 能够将
<code>8 f-stops</code> 提升至 <code>25 f-stops</code>。</p>
<!-- ![Filmic Blender的dynamic range爆表](){
    class=b-lazy
    data-src=/assets/images/2017-BlenderFilmic/new-f-stops.png
} -->
<figure>
<img src="/assets/images/2017-BlenderFilmic/new-f-stops.png"
alt="Filmic Blender的dynamic range爆表" />
<figcaption aria-hidden="true">Filmic Blender的dynamic
range爆表</figcaption>
</figure>
<p>最重要的是Troy非常慷慨将 <code>Filmic Blender</code>
对community开源，并且完全免费。</p>
<h3 id="安装-filmic-blender">安装 Filmic Blender</h3>
<ol type="1">
<li><p><a
href="https://github.com/sobotka/filmic-blender">Github项目页面</a>找到
<em>Clone or Download</em> 按钮， 点击后选择 <em>Download Zip</em>
下载zip压缩包。</p></li>
<li><p>解压到blender <strong>datafiles</strong> 目录下。</p>
<ul>
<li>Windows用户，这个目录处于blender安装目录下，可能是 C:/Program
Files/Blender Foundation/Blender/&lt;version&gt;/datafiles</li>
<li>Linux用户，/home/$user/.blender/&lt;version&gt;/datafiles。其中
<em>$user</em> 及用户名。</li>
<li>Mac用户，进入Resources文件夹后，blender.app/Contents/Resources/&lt;version&gt;/datafiles</li>
</ul></li>
<li><p>将 <strong>datafiles</strong> 目录下原来的
<strong>colormanagement</strong> 改为别的名字（例如
colormanagement_bak）作为备份。</p></li>
<li><p>将改解压的文件夹改为 <strong>colormanagement</strong>
作为新的颜色管理配置。 注意打开后能看到 <em>looks</em> 以及
<em>luts</em> 这两个文件夹，确保目录结构正确。</p></li>
<li><p>打开blender，进入 <strong>Scene</strong> 标签，在 <strong>Color
Management</strong> 下点开 <strong>View</strong>
应该能看到如下图的选项。 其中 <code>Filmic Log Encoding Base</code>
就是我们的主角了。</p>
<p><!-- ![Filmic Blender Color Management 菜单](){
     class=b-lazy
     data-src=/assets/images/2017-BlenderFilmic/menu-filmic.png
 } --> <img src="/assets/images/2017-BlenderFilmic/menu-filmic.png"
alt="Filmic Blender Color Management 菜单" /></p></li>
</ol>
<h3 id="使用-filmic-blender">使用 Filmic Blender</h3>
<ul>
<li><p><code>color management</code>下面的 <code>view</code> 选为
<code>Filmic Log Encoding Base</code> 。</p></li>
<li><p>将 <code>look</code> 选为 <code>Base Contrast</code> 。</p>
<blockquote>
<p>没有选择 <code>None</code> 时候，类似于相片Raw格式，<code>look</code>
中的选项相当于应用一个 lookup table。</p>
</blockquote></li>
<li><p>在高动态范围下，你可以将场景里面的光源亮度提高，让你的场景拥有足够的光线。</p></li>
</ul>
<h3 id="使用-false-color-让场景的曝光度明确可见">使用 False Color
让场景的曝光度明确可见</h3>
<p>以往调整光源的时候往往就是肉眼观察，然后不断尝试感觉差不多了。
但现在Filmic Blender有一个量化工具来辅助， 当 <code>look</code> 设为
<code>False Color</code>，就能够将场景内曝光度可视化，可以根据其来调整光源强度。</p>
<p>该设置下，会用不同颜色表示不同的曝光度:</p>
<table style="width:64%;">
<colgroup>
<col style="width: 20%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Value</th>
<th style="text-align: left;">Color</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Low Clip</td>
<td style="text-align: left;">Black</td>
</tr>
<tr class="even">
<td style="text-align: left;">-10 EV</td>
<td style="text-align: left;">Purple</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-7 EV</td>
<td style="text-align: left;">Blue</td>
</tr>
<tr class="even">
<td style="text-align: left;">-4 EV</td>
<td style="text-align: left;">Cyan</td>
</tr>
<tr class="odd">
<td style="text-align: left;">-2 EV</td>
<td style="text-align: left;">Green</td>
</tr>
<tr class="even">
<td style="text-align: left;">0 EV</td>
<td style="text-align: left;">Grey</td>
</tr>
<tr class="odd">
<td style="text-align: left;">+2 EV</td>
<td style="text-align: left;">Green</td>
</tr>
<tr class="even">
<td style="text-align: left;">+4 EV</td>
<td style="text-align: left;">Yellow</td>
</tr>
<tr class="odd">
<td style="text-align: left;">+5.5 EV</td>
<td style="text-align: left;">Red</td>
</tr>
<tr class="even">
<td style="text-align: left;">High Clip</td>
<td style="text-align: left;">White</td>
</tr>
</tbody>
</table>
<p>白色就是 <code>white cliping</code>，黄色以及红色较亮，黑色就是
<code>black cliping</code>，蓝色以及紫色较暗。</p>
<!-- ![原来的光照](){
    class=b-lazy
    data-src=/assets/images/2017-BlenderFilmic/FalseColor-light-before.jpg
} -->
<figure>
<img src="/assets/images/2017-BlenderFilmic/FalseColor-light-before.jpg"
alt="原来的光照" />
<figcaption aria-hidden="true">原来的光照</figcaption>
</figure>
<p>这个是改进前的场景，打不都是绿色，而且曝光最高的部分才黄色级别，所以光线严重不足。</p>
<!-- ![增强亮度后的光照](){
    class=b-lazy
    data-src=/assets/images/2017-BlenderFilmic/FalseColor-light38&10.jpg
} -->
<figure>
<img
src="/assets/images/2017-BlenderFilmic/FalseColor-light38&amp;10.jpg"
alt="增强亮度后的光照" />
<figcaption aria-hidden="true">增强亮度后的光照</figcaption>
</figure>
<p>改进后，盘子有些反光，然后面包圈上的酱料有少许高光。</p>
<p>最后再将 <code>look</code> 改回
<code>Base Constract</code>，查看下改进后的渲染效果：</p>
<!-- ![改进后的渲染效果](){
    class=b-lazy
    data-src=/assets/images/2017-BlenderFilmic/light38&10_1.jpg
} -->
<figure>
<img src="/assets/images/2017-BlenderFilmic/light38&amp;10_1.jpg"
alt="改进后的渲染效果" />
<figcaption aria-hidden="true">改进后的渲染效果</figcaption>
</figure>
<p>原先光源数据：主光源15，辅光源5。改进后光源数据：主光源38，辅光源10。
亮度提升了一倍多，场景内光线充足后，我们的渲染效果就闪耀了。</p>
<h2 id="总结">总结</h2>
<p>Blender 的 Cycles 渲染器效果非凡，我们通过修正了其color
management，最后补足最后缺陷。 使其 PBR<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>
效果的以正确显示，最终达到照片级的真实效果。</p>
<p>视频大概3月份发布，我也差不多一个月后发现并观看了，并用我的面包圈作品练手。
本来当时做完渲染作品，就想写这篇文章来推荐这个我极大受益的方法，
但拖了4个月，眼看blender
2.8版本就要正式版了，2.8内置类似<code>Filmic</code>的功能，再不写有些内容就快过时了。</p>
<p>虽说即将到来的新版本已经意识到并解决老blender的这个问题，但这篇文章或者上述的教程视频依旧有用，
因为会介绍原理层面（很容易理解），知其所以然。</p>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://www.unrealengine.com/en-US/blog/unreal-engine-4-15-released?lang=en-US">4.15发布日志</a>
新的基于<code>ACES</code>的<code>Filmic Tonemapping</code>特性以及对应的新的<code>Post Progress</code>后期处理的工具，
如果你用过以前版本，4.15的Post
Progress有很大变化，而且相关工作流<code>workflow</code>有些不同，UE4团队有相关新特性的U2B视频教程
<a href="https://youtu.be/A-wectYNfRQ">Filmic Tonemapper | Feature
Highlight</a><a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p> Academy Color Encoding System
是在电影以及电视领域用于管理色彩的工业标准。 此处 Academy
也是奥斯卡奖的那个学院。更多关于ACES介绍浏览 <a
href="http://www.oscars.org/science-technology/sci-tech-projects/aces">http://www.oscars.org/science-technology/sci-tech-projects/aces</a>
<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Physically Based Rendering 基于物理现实的渲染<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content><author><name></name></author><category term="CG" /><category term="PBR" /><category term="ACES" /><category term="blender" /><category term="CG" /><summary type="html"><![CDATA[[2020-01 Update] 于2018年10月，Blender 2.8正式版发布，默认color management即本文提及的Flimic, 应该就是把其整合进 Blender，本文关于 Flimic 使用方法依旧有用。 我曾经在我的文章 Blender Cycles渲染作品 面包圈 提到发现一个改进方法，能够大幅提高渲染 render 效果。 本文我会通过上面提及的面包圈作品作为实例，来谈论原生blender dynamic range 动态范围的限制。 以及突破限制的方式，即Filmic Blender插件，最终能带来不可思议的照片级渲染效果。 渲染效果对比 右边改进的作品 提升效果明显 这个改进方法我是从blenderguru的一个非常棒的youtube教程视频 The Secret Ingredient to Photorealism学到的。 我极力推荐观看。我文章基本就是根据视频整理得出，额外加些我的内容。 另外本文基于blender编写，但是里面相当多的内容并不局限于blender，甚至Filmic的幕后实现也是基于其他领域的成果（下面正文我会介绍）。 所以如果你使用其他CG或者渲染软件，以及别的相关领域也建议了解下。]]></summary></entry><entry><title type="html">Blender Cycles渲染作品 面包圈</title><link href="https://www.mix-flow.com/works/blender/cycles/2017/04/02/blender-cycles-render-donuts.html" rel="alternate" type="text/html" title="Blender Cycles渲染作品 面包圈" /><published>2017-04-02T02:27:54+08:00</published><updated>2017-04-02T02:27:54+08:00</updated><id>https://www.mix-flow.com/works/blender/cycles/2017/04/02/blender-cycles-render-donuts</id><content type="html" xml:base="https://www.mix-flow.com/works/blender/cycles/2017/04/02/blender-cycles-render-donuts.html"><![CDATA[<p>Rendering in <strong>Blender</strong>’s <strong>Cycles</strong>
render engine.</p>
<p>This was my first 3D project, based on a tutorial from <a
href="http://www.blenderguru.com/">BlenderGuru</a>.</p>
<blockquote>
<p><em>Updated on 2023-03-13</em> The tutorial had been quite famous
inside blender communitiy, The author published <a
href="https://www.youtube.com/watch?v=nIoXOplUvAw&amp;list=PLjEaoINr3zgFX8ZsChQVQsuDSjEqdWMAD">a
new series on youtube</a> in 2022.</p>
</blockquote>
<p>The render qualify didn’t reached current ones when I first followed
the tutorial. But recently I discovered a way to improve cycles
rendering result, and decided to apply it to this early project. The
result is very satisfying.</p>
<!-- ![主视角](){.b-lazy data-src="/assets/images/2017-Donuts/result1.jpg"} -->
<figure>
<img src="/assets/images/2017-Donuts/result1.jpg"
alt="Main view/camera" />
<figcaption aria-hidden="true">Main view/camera</figcaption>
</figure>
<!--more-->
<p>The method involved changging the <strong>color management</strong>
to <strong><em>Flimic</em></strong>, I have also written <a
href="%7B#%%20post_url%20/2017-08-26-The-Secret-Ingredient-to-Photorealism%20%%7D">another
article with more detail</a>.</p>
<blockquote>
<p>Flimic is now the <strong>default</strong> color managment setting
since blender 2.8(around 2018-10)</p>
</blockquote>
<figure>
<img src="/assets/images/filmic-before&amp;after.jpg"
alt="comparsion of the non-flimic and flimic" />
<figcaption aria-hidden="true">comparsion of the non-flimic and
flimic</figcaption>
</figure>
<!-- ![俯视 并不是专门设计的视角，只是为了从另一个角度查看](){.b-lazy data-src="/assets/images/2017-Donuts/result2.jpg" loading="lazy"} -->
<figure>
<img src="/assets/images/2017-Donuts/result2.jpg" alt="Top-down view" />
<figcaption aria-hidden="true">Top-down view</figcaption>
</figure>
<p>I made a few tweaks by lowering the lightness and enhancing the
contrast of the last image, as I thought it was a little
over-exposed.</p>
<!-- ![上张俯视效果图 后期处理](){:class="b-lazy" data-src="/assets/images/2017-Donuts/result3.jpg" loading="lazy"} -->
<figure>
<img src="/assets/images/2017-Donuts/result3.jpg"
alt="Previous top-down view with post processing" />
<figcaption aria-hidden="true">Previous top-down view with post
processing</figcaption>
</figure>]]></content><author><name></name></author><category term="works" /><category term="blender" /><category term="cycles" /><category term="blender" /><category term="cycles" /><category term="render" /><category term="PBR" /><category term="3D" /><category term="CG" /><summary type="html"><![CDATA[Rendering in Blender’s Cycles render engine. This was my first 3D project, based on a tutorial from BlenderGuru. Updated on 2023-03-13 The tutorial had been quite famous inside blender communitiy, The author published a new series on youtube in 2022. The render qualify didn’t reached current ones when I first followed the tutorial. But recently I discovered a way to improve cycles rendering result, and decided to apply it to this early project. The result is very satisfying. Main view/camera]]></summary></entry><entry xml:lang="zh"><title type="html">使用Ruby写一个Racket(Scheme)解释器</title><link href="https://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby.html" rel="alternate" type="text/html" title="使用Ruby写一个Racket(Scheme)解释器" /><published>2017-02-20T13:38:05+08:00</published><updated>2017-02-20T13:38:05+08:00</updated><id>https://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby</id><content type="html" xml:base="https://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby.html"><![CDATA[<!-- TODO  img center '/assets/images/2017-RacketOnRuby/lambda.svg' 200 'lambda symbol'  -->
<p>如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器<code>interpreter</code>来练个手。</p>
<p>我学的是 Lisp(或者说Scheme)
方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。<br />
毕竟之前也接触过很多语言，基本都是学的语言特性<code>feature</code>，和其流行的package使用(比如web框架)。很少接触过语言实现<code>language implemention</code>的知识。</p>
<p>当自己能写出解释器的时候，感觉到一种新的学习语言的体验。</p>
<p>这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。</p>
<p>项目github链接：<a
href="https://github.com/mixflow/RacketOnRuby/">https://github.com/mixflow/RacketOnRuby/</a>
<!--more--></p>
<h2 id="语言相关介绍">语言相关介绍</h2>
<p>Ruby现在还算有些名声，现在的程序员即使没用过的，可能都知道有这门语言。<br />
但是Lisp Scheme可能很多程序员都没听说过，
我当年阅读了别人推荐的《黑客与画家》
这本书才有所了解，在此之前我似乎连Lisp或者Scheme的名字都没见过。
所以有必要先简介一下。</p>
<h3 id="lisp-scheme-racket-是什么">Lisp Scheme Racket 是什么?</h3>
<p>Lisp是一门诞生于上个世纪50年代的语言。其后有很多相同思想的语言，都算得上Lisp家族的，一般被称为Lisp
方言<code>dialect</code>， 其中就包括这里提及的另外两个语言Racket
Scheme。Scheme年代更加久远，影响也大些。Racket相比之下更年轻些。</p>
<p>这篇文章只涉及语言基本简单特征实现，这块哪怕语法上面Racket
Scheme都没什么区别，
所以这里的Racket解释器也可看作Scheme解释器。也就是说能解释执行Scheme代码。</p>
<h3 id="why-use-ruby">Why use Ruby?</h3>
<ol type="1">
<li>当时正好也在学Ruby，所以就用Ruby实现下，纯练手。</li>
<li>这个是第二个编译器实现。最早第一个是当时学习Racket的时候，使用Racket本身实现的，编写了一个<code>metacirclar evaluator</code>，这种方式可以跳过<code>parse</code>步骤（详见紧接着的下文），因为写的代码就已经是AST了（依旧详见下文）。那么用Ruby来实现Racket的话，是需要<code>parser</code>，所以也能再多练一些(虽说parser也没什么复杂的)。</li>
<li>《黑客与画家》中
<em>“如果回到1975年，你声称它(Ruby)是一种有着自己语法的Lisp方言，没有人会提出反对意见。”</em>。<br />
作者认为Ruby也可以视为Lisp的一种方言。那么我反过来通过Lisp的方言来实现Lisp，想法有些古怪，但我认为有点意思。</li>
</ol>
<h2 id="实现一个编程语言通常的步骤">实现一个编程语言通常的步骤</h2>
<p>下面涉及的是一个典型的语言实现<code>language implemention</code>的流程：</p>
<ol type="1">
<li>首先接受一串字符串<code>string</code>，其内容就是用此语言编写的程序。如果该字符串不是符合语法结构<em>syntactically
well-formed</em>（比如关键字拼写错误等），分析器<code>parser</code>会报错。</li>
<li>如果没有上述的语法错误，parser会生成一个树<code>tree</code>来表示程序。这个树一般称为<code>abstract-syntax tree</code>，简称为<code>AST</code>。
<ul>
<li>如果语言有<code>类型检查 type-checking</code>或其他原因，认定AST仍然不是一个合法的程序。
<code>类型检查器 type-checker</code>就会生成错误信息。</li>
<li>如果没有上述错误, AST就会被传递给后续流程。</li>
</ul></li>
<li>实现目标编程语言<code>language B</code>的剩余流程，基本就是如下两种方案。
<ul>
<li>可以用另一门语言<code>language A</code>编写<code>解释器 interpreter</code>来接受使用<code>language B</code>编写的程序，并最终产生结果。这里用来实现interpreter的language
A，有个专门术语称呼：<code>metalanguage</code>。</li>
</ul>
<blockquote>
<p>如果把这个<code>language A</code>程序称作<code>evaluator for B</code>（evaluate中文对应术语一般叫求值，大概意思达到了，但我个人觉得不太准确）或者<code>执行器 executor for B</code>，可能会更直白些。但<code>解释器 interpreter</code>是约定俗成的术语。</p>
</blockquote>
<ul>
<li>另外一种方式再<code>language A</code>写一个<code>编译器 compiler</code>来将<code>language B</code>写的程序生成一个等价<em>equivalent</em>
<code>language C</code>的程序。
然后再使用早已存在的<code>language C</code>语言实现。</li>
</ul>
<blockquote>
<p><code>编译器 compiler</code>可能称为<code>翻译器 translator</code>更好，与interpreter同样的原因，compiler是个普遍使用的术语。</p>
</blockquote></li>
</ol>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/d/d6/Parser_Flow%D5%B8.gif"
alt="implementing program language workflow from wikipedia parsing" />
<figcaption aria-hidden="true">implementing program language workflow
from <a href="https://en.wikipedia.org/wiki/Parsing">wikipedia
parsing</a></figcaption>
</figure>
<p>另外要说教下，编译器以及解释器只是<strong>编程语言实现方式的特征<em>the
feature of a particular programming language
implementation</em></strong>，而不是编程语言自身的特征<em>the feature of
the programming language</em>。所以“编译性语言” <em>compile
language</em> 或者“解释性语言” <em>interpreter language</em>
的说法<strong>完全没有意义</strong>。完全可以给Lisp,Scheme系语言编写一个compiler(这些语言的解释器实现比较常见)，给C语言编写一个解释器也是完全可行的。</p>
<h2 id="racket基本语法以及parser实现">Racket基本语法以及parser实现</h2>
<p>建议先在<a
href="http://download.racket-lang.org/">Racket官网下载</a>原生Racket以及配套IDE
DrRacket，写Racket或者Scheme程序方便些。
另外本文interpreter实现基本不包含检测和错误处理，所以测试代码最好先在原生Racket里面执行下。</p>
<p>需要快速了解Racket基本语法，推荐此篇快速介绍文章<a
href="https://learnxinyminutes.com/docs/racket/">Learn X in Y minutes,
When x = Racket</a>。</p>
<h3 id="代数运算">代数运算</h3>
<!-- Jekyll, replace code block with caption to Jekyll highlight tag -->
<figure class="highlight code-block">
<figcaption>
<span class="language">lisp</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279">(</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #D7827E">2</span><span style="color: #575279"> (</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #D7827E">2</span><span style="color: #575279"> </span><span style="color: #D7827E">3</span><span style="color: #575279">))</span></span></code></pre>
</figure>
<p>先来个简单的Racket代码例子，上述代码较内层括号<code>(* 2 3)</code>是乘法运算，然后在外层括号内再将上述乘法运算结果加上2。
整个代码等价于数学或者常见编程语言<code>2 + 2 * 3</code>代码意义。</p>
<p>一开始就比较不同寻常，对于此类Racket代码可以看作<code>操作符 operator</code>以及<code>操作数 operand</code>的组合，再用括号包裹。比如<code>(+ 1 1)</code>就可以把<code>+</code>看作操作符。另外可以括号形式的代码嵌套，比如上述先乘后加的代数运算。</p>
<p>这种代码形式，实际非常简单，我们可以给一个更加明确的定义如下节。</p>
<h3 id="racket所有的东西都是">Racket所有的东西都是：</h3>
<p>就两种！</p>
<ol type="1">
<li>一个<code>atom</code>，比如数字<code>3</code>、字符串<code>"hello"</code>、<code>#t</code>、<code>#f</code>、<code>null</code>。也包括一种atom的：<code>识别符 identifier</code>,可以是<code>变量variable</code>,<br />
或者是<code>特别形式special form</code>诸如<code>define</code>、<code>lambda</code>、<code>if</code>。(涉及的名词或者术语，不理解没关系，再后文会一一介绍)</li>
<li>或者是在括号的一序列<em>sequence</em>东西<code>(t1 t2 t3 ... tn)</code>。</li>
</ol>
<p>该定义还有个专门的名称<a
href="https://en.wikipedia.org/wiki/S-expression">S-expression</a>，随着Lisp诞生给出的定义用来描述Lisp。</p>
<p>详说下第二种情况。括号里的第一东西t1，影响余下的序列中的东西。
如果是<code>special form</code>，比如<code>define</code>，以为定义一个东西，要么是变量<em>variable</em>，要么是函数<em>function</em>（<code>lambda</code>）。</p>
<p>如果不是<code>special form</code>，剩余情况一般是函数执行<em>function
call</em>，很多东西在Racket里都是函数，比如加减<code>+</code>和<code>-</code>。</p>
<p>在Racket里括号是很常见的，而且括号作用非常明确。不会遇到<code>f x y</code>是<code>(f x) y</code>还是<code>f (x y)</code>的疑惑。
Racket的括号直接影响着<code>解析parsing</code>，将代码转换成树形结构。实际上Racket代码本身就是树形结构。</p>
<p>如果没有了解过Lisp系语言，大部分人看到一段比较长的代码，都会觉得充满了括号的怪异语法。如果能抛开这些成见，学习使用后实际上能很快适应。</p>
<h3 id="token">Token</h3>
<p>具体到parser中第一步<code>生成token token generator</code>或者叫<code>词汇分析lexical Analysis</code>。可以参照上文实现语言通常流程小节引用的流程图，其中’parser’部分。</p>
<p>这个过程就是把代码字符串分割成多个有意义的符号。这个过程一般使用正则表达式<em>regural
expression</em>简称<em>regex</em>。这些符号专门的术语就是<code>token</code>。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> write token generator on ruby
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">class</span><span style="color: #575279"> </span><span style="color: #56949F">Racket</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">tokenize</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">str</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        str</span><span style="color: #797593">.</span><span style="color: #B4637A; font-style: italic">gsub</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;(&quot;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;( &quot;</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> add space after &#39;(&#39;</span></span>
<span class="line"><span style="color: #575279">           </span><span style="color: #797593">.</span><span style="color: #B4637A; font-style: italic">gsub</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;)&quot;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot; )&quot;</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> add space before &#39;)&#39;</span></span>
<span class="line"><span style="color: #575279">           </span><span style="color: #797593">.</span><span style="color: #575279">split</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot; &quot;</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> split string into an array(tokens) base on whitespaces</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>快速简介下ruby，本文在前言里面提及了面向新手，所以会对于不了解ruby的读者涉及一些介绍，<strong>这部分内容我会用引言块注明（如下），如果不需要，随意跳过。</strong>
不光会有ruby知识，还有一些别的编程知识。</p>
<blockquote>
<p>Ruby是一种<code>动态类型dynamic type</code>
<code>面向对象object oriented</code>编程语言。我定义了一个名叫Racket的<code>类class</code>。
其中定义了一个名叫tokenize的函数。函数有一个’str’的参数，用来接收代码字符串。注意class和method都使用了end明确表明各自代码块的结束部分，ruby里面大部分代码快都需要end结尾，比如if。<br />
另外ruby函数会自动返回最后一个对象。当然你也可以明确<em>explicitly</em>使用<code>return</code>，比如条件（if）分支需要返回的情形。</p>
</blockquote>
<p>代码很简单，先将这对括号”()“内测增加一个空格，方便最后<code>分割split</code>操作。<code>gsub</code>便是替换操作。</p>
<blockquote>
<p><code>str.gsub(...).gsub(...).split(...)</code>这种连着执行函数模式，术语叫做<em>chaining</em>。自己写的代码函数返回对象即可做到。<br />
另外这种风格并不是ruby或者别的某个语言特有的，是一种<code>习惯用法idiom</code>。好处就是少些变量名或者赋值，另外也没必要构造一个大而全方法，完全可以构建更合理多个方法并连续调用从而达到目标。</p>
</blockquote>
下面便测试下上述代码
使用系统的命令行工具到相应的代码目录。确保安装ruby后输入<code>irb</code>命令，定义一段代码string，传入<code>tokenize</code>函数生成token。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> Test Tokenize in irb
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">c</span><span style="color: #797593">:</span><span style="color: #575279">\</span><span style="color: #575279; font-style: italic">Projects</span><span style="color: #575279">\</span><span style="color: #575279; font-style: italic">RacketOnRuby</span><span style="color: #286983">&gt;</span><span style="color: #575279">irb</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">001</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #286983">&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">load</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;racket.rb&#39;</span></span>
<span class="line"><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">002</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #286983">&gt;</span><span style="color: #575279"> r </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #56949F">Racket</span><span style="color: #797593">.</span><span style="color: #286983">new</span></span>
<span class="line"><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic">&lt;Racket:0x00000002e67df8&gt;</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">003</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #286983">&gt;</span><span style="color: #575279"> str </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #EA9D34">%{(+ 1</span></span>
<span class="line"><span style="color: #EA9D34">irb(main)</span><span style="color: #797593">:</span><span style="color: #D7827E">004</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #EA9D34">&quot;      (* 2</span></span>
<span class="line"><span style="color: #EA9D34">irb(main):005:0&quot;</span><span style="color: #575279">         </span><span style="color: #797593">(</span><span style="color: #286983">-</span><span style="color: #575279"> </span><span style="color: #D7827E">7</span><span style="color: #575279"> </span><span style="color: #D7827E">3</span><span style="color: #797593">)))</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">006</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #EA9D34">&quot; }</span></span>
<span class="line"><span style="color: #EA9D34">=&gt; &quot;</span><span style="color: #797593">(</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #D7827E">1</span><span style="color: #575279">\n     </span><span style="color: #797593">(</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #D7827E">2</span><span style="color: #575279">\n        </span><span style="color: #797593">(</span><span style="color: #286983">-</span><span style="color: #575279"> </span><span style="color: #D7827E">7</span><span style="color: #575279"> </span><span style="color: #D7827E">3</span><span style="color: #797593">)))</span><span style="color: #575279">\n</span><span style="color: #EA9D34">&quot;</span></span>
<span class="line"><span style="color: #EA9D34">irb(main):007:0&gt; p r.tokenize(str)</span></span>
<span class="line"><span style="color: #EA9D34">[&quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">+</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">1</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">*</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">2</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">-</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">7</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">3</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;]</span></span>
<span class="line"><span style="color: #EA9D34">=&gt; [&quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">+</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">1</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">*</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">2</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">-</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">7</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">3</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;]</span></span></code></pre>
</figure>
<blockquote>
<ul>
<li>第1行（最左边的行号）<code>irb</code>进入ruby
REPL。没听过REPL，先粗略认为REPL就是专门执行代码的命令工具。下文<a
href="#工具repl-read-eval-print-loop">REPL章节</a>会详细的涉及，因为我们实现Racket也要写个Racket的REPL，来方便测试。</li>
<li>第2行加载包含Racket class的相应的ruby file。
我的ruby文件名就叫做racket.rb。</li>
<li>第4行创建一个Racket的对象<code>实例instance</code>。该实例将来调用相应的函数进行<code>tokenize</code>以及后续的操作。Ruby的语法syntax，很多时候执行函数都可以省略括号，比如此处创建对象的时候调用<code>new</code>构造函数，可选写法：<code>Racket.new()</code>两种代码等价的。</li>
<li>6行到9行，定义了变量名为<code>str</code>的code string。
<code>%{...}</code>是ruby定义多行字符串的一种语法syntax。</li>
<li>第10行，irb会自动输出之前代码执行结果返回的对象（包括之前的3、5行）。其中把换行转义成了’’输出在一行。</li>
<li>第11行，调用<code>tokenize</code>函数，并传入上一步定义的string。并打印输出结果即tokens</li>
</ul>
</blockquote>
<blockquote>
<p>可以把上述命令行中的ruby测试代码放入专门的rb文件，这样就无需在每次重新测试再敲代码。例如github项目中的<em>example.rb</em>，直接系统命令行执行<code>ruby example.rb</code></p>
</blockquote>
<p>此前代码，在<code>tokenize</code>函数多了第一步处理是把多个空白符转化成单个隔空”
“，然而写这篇文章的时候，我重新审查了下代码，并不需要多此一举。多余的代码：<code>str.gsub(/\s{2,}/, " ")</code></p>
<p>原因是<code>split</code>方法传入单个空格字符串的时候，会基于空白符<em>whitespace</em>分割，而且会忽略余下的紧挨着的空白符。<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>token生成好了，下面便是分析token并生成AST了。</p>
<h2 id="abstract-syntax-tree-parse-tree">Abstract Syntax Tree (Parse
Tree)</h2>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">generate_ast</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">tokens</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">aux</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">tokens</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">acc</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> tokens</span><span style="color: #797593">.</span><span style="color: #575279">empty?</span></span>
<span class="line"><span style="color: #797593">            </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> no tokens left, return result</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> acc</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        token </span><span style="color: #286983">=</span><span style="color: #575279"> tokens</span><span style="color: #797593">.</span><span style="color: #575279">shift </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> get first token</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;(&#39;</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> token </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> start one s-expression</span></span>
<span class="line"><span style="color: #575279">            sub_ast </span><span style="color: #286983">=</span><span style="color: #575279"> aux tokens</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">[]</span></span>
<span class="line"><span style="color: #575279">            acc</span><span style="color: #797593">.</span><span style="color: #575279">push sub_ast</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">            aux</span><span style="color: #797593">(</span><span style="color: #575279">tokens</span><span style="color: #797593">,</span><span style="color: #575279">  acc</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> recursive call to continue handling rest tokens</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">elsif</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;)&#39;</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> token </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> end one s-expression</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> acc</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">            acc</span><span style="color: #797593">.</span><span style="color: #575279">push atom</span><span style="color: #797593">(</span><span style="color: #575279">token</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> convent current token to atom</span></span>
<span class="line"><span style="color: #575279">            aux tokens</span><span style="color: #797593">,</span><span style="color: #575279"> acc </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> recursive</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">    aux tokens</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">[]</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> initial call helper</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>真正起作用的是<code>generate_ast</code>内部定义<code>aux</code>（<em>auxiliary辅助</em>,
<em>helper</em>）的方法，处理tokens，其参数<code>acc</code>（<em>accumulator累加器</em>）存放的处理得到的AST。</p>
<p>主要使用<code>递归 recursion</code>从左到右处理<code>tokens</code>里面的每一个token：</p>
<ul>
<li>tokens为空的时候，返回<code>acc</code>即AST结果。</li>
<li>当遇到左括号时，说明遇到一个s-expression的序列，递归调用<code>aux</code>方法的时候给<code>acc</code>参数传入一个新的空array（上述第10行代码），用来存储这部分subdivision
s-expression序列对应的AST结果。<br />
第11行，递归调用处理完返回<code>subdivision acc</code>结果，追加到原来acc后面。</li>
<li>当遇到右括号的时候，说明s-expression的结束，返回结果<code>acc</code>，对应上一点的<code>subdivsion acc</code>。<br />
</li>
<li>剩余其他情况，将token转化为atom，紧接的下文涉及atom实现细节。</li>
</ul>
<p>实际<code>generate_ast</code>方法简化下就是匹配括号的代码，包括嵌套<em>nested</em>结构。</p>
<blockquote>
<p>上述代码并没有检测括号是否匹配，因为需要文章简洁，这里只贴出不检测括号的代码，github上面的源文件里面包含有完整的括号检测。<br />
racket里面除了可以使用圆括号()，也可以使用方括号[]，两者功能作用没有区别，编码习惯在某些地方会使用[]，但不遵循也不会有什么实质影响。唯一注意的就是要对应的括号匹配，不能混用，比如<code>(+ 1 1]</code>就是语法不正确。</p>
</blockquote>
<h3 id="atom">Atom</h3>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> s-expression atom
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">atom</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">token</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    str_part </span><span style="color: #286983">=</span><span style="color: #575279"> token</span><span style="color: #797593">[</span><span style="color: #EA9D34">/^&quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">.*</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;$/</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> try match string(start and end with &quot;)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #286983">not</span><span style="color: #575279"> str_part</span><span style="color: #797593">.</span><span style="color: #575279">nil?</span></span>
<span class="line"><span style="color: #575279">        str_part</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> token</span><span style="color: #797593">[</span><span style="color: #EA9D34">/</span><span style="color: #797593">(</span><span style="color: #EA9D34">?=</span><span style="color: #797593">(</span><span style="color: #286983">\.</span><span style="color: #EA9D34">|</span><span style="color: #797593">[</span><span style="color: #286983">eE</span><span style="color: #797593">]))(</span><span style="color: #286983">\.\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?</span><span style="color: #797593">([</span><span style="color: #286983">eE</span><span style="color: #797593">][</span><span style="color: #286983">+-</span><span style="color: #797593">]</span><span style="color: #EA9D34">?</span><span style="color: #286983">\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?$/</span><span style="color: #797593">]</span><span style="color: #575279">  </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> decimal</span></span>
<span class="line"><span style="color: #575279">        token</span><span style="color: #797593">.</span><span style="color: #575279">to_f</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> token</span><span style="color: #797593">[</span><span style="color: #EA9D34">/^</span><span style="color: #286983">\d</span><span style="color: #EA9D34">+$/</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> integer</span></span>
<span class="line"><span style="color: #575279">        token</span><span style="color: #797593">.</span><span style="color: #575279">to_i</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> symbol</span></span>
<span class="line"><span style="color: #575279">        token</span><span style="color: #797593">.</span><span style="color: #575279">to_sym</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>刚才上文我们已经处理了s-expression序列，即<a
href="#racket所有的东西都是">上文提及s-expression</a>第二种情形。此处<code>atom</code>为第一种情况，具体又有细分，可能是string、数字、也有可能是<code>identifier</code>。对应代码中<code>if</code>语句各个分支，通过正则式尝试匹配<code>token</code>（Ruby
string对象）：</p>
<ol type="1">
<li><p>在Racket中头尾各一个双引号<code>"</code>来包含字符串。第一个if便是通过正则式匹配首尾”，如果的确是string，其中间部分取出就是对应的Ruby
string类型的对象。</p></li>
<li><p>第二个if分支判断是否为浮点数。这里的正则式看起来很复杂，简单代替方案是仅仅匹配小数点（正则式为
<code>/\.\d+$/</code>）。这里复杂的正则式是除了用来匹配小数外，还能匹配指数<em>exponential</em>，Ruby中指数类似1e5也算作浮点数(等同于10000.0，Racket中也是同样的)。to_f便是将string转化为float浮点数的方法。这里举出4个数<code>.003</code>
<code>0.5</code> <code>32e3</code>
<code>.24e5</code>，这些都是浮点数，我们的正则式便是能够匹配出对应小数点部分以及指数部分，测试代码如下，第一行这四个数尝试使用该正则式匹配，第二行是匹配部分的结果:</p>
<figure class="highlight code-block">
<figcaption>
<p><span class="language">ruby</span> decimal and exponential</p>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279">    </span><span style="color: #797593">[</span><span style="color: #EA9D34">&#39;.003&#39;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;0.5&#39;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;32e3&#39;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;.24e5&#39;</span><span style="color: #797593">].</span><span style="color: #575279">map</span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">num</span><span style="color: #797593">|</span><span style="color: #575279"> num</span><span style="color: #797593">[</span><span style="color: #EA9D34">/</span><span style="color: #797593">(</span><span style="color: #EA9D34">?=</span><span style="color: #797593">(</span><span style="color: #286983">\.</span><span style="color: #EA9D34">|</span><span style="color: #797593">[</span><span style="color: #286983">eE</span><span style="color: #797593">]))(</span><span style="color: #286983">\.\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?</span><span style="color: #797593">([</span><span style="color: #286983">eE</span><span style="color: #797593">][</span><span style="color: #286983">+-</span><span style="color: #797593">]</span><span style="color: #EA9D34">?</span><span style="color: #286983">\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?$/</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> =&gt; [&quot;.003&quot;, &quot;.5&quot;, &quot;e3&quot;, &quot;.24e5&quot;]</span></span></code></pre>
</figure>
<blockquote>
<p>Ruby Array的map方法，是将其中每个元素都进行block中处理。
<code>{ |num| ...}</code>形式就是block，此处Array.map会往block的num参数
传入单个元素。</p>
</blockquote></li>
<li><p>第三个if分支，尝试匹配是否为整数。to_i便把string是转化整数<em>integer</em>的方法</p></li>
<li><p>最后一个else分支，剩下情况可能是变量名或者special
form比如<code>lambda</code> <code>define</code>等。最后转化为Ruby
<code>符号Symbol</code>类型。所谓symbol类似string，symbol为不可变<code>immutable</code>，而且其值一样的话，就是同一个对象。</p>
<blockquote>
<p>Ruby中symbol是以<code>:</code>作为开头，例如<code>:hello</code>。两两比对的时候symbol效率更高。不像string一个一个字符<em>char</em>进行比对，symbol直接比对两者在内存中是否为同一个对象。</p>
</blockquote></li>
</ol>
<p>到此为止，实现了生成AST的部分，下面就要涉及interpreter部分了。</p>
<h2
id="eval方法实现executorinterpreter">eval方法实现executor(interpreter)</h2>
<p>有些表达式<em>expression</em>中会包含变量<em>variable</em>，求值<em>evaluate</em>这些表达式就需要<code>environment</code>，通过variable获得对应值<em>vaLue</em>。</p>
<p>environment的实现是<code>metalanguage</code>的一部分，metalanguage这里就是我们使用的Ruby。这里使用hash数据结构来代表environment。</p>
<h3 id="完成代数运算eval">完成代数运算eval</h3>
文章一开始的提及的代数运算的Racket代码<code>(+ 1 (* 2 3))</code>，首先将其实现:
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> eval algebra operators
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">()</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">{</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593">:</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">y</span><span style="color: #797593">|</span><span style="color: #575279"> x</span><span style="color: #286983">+</span><span style="color: #575279">y</span><span style="color: #797593">},</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593">:</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">y</span><span style="color: #797593">|</span><span style="color: #575279"> x</span><span style="color: #286983">*</span><span style="color: #575279">y</span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Numeric</span></span>
<span class="line"><span style="color: #575279">        exp </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> is a number(integer and float) return itself</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #286983">or</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">*</span></span>
<span class="line"><span style="color: #575279">        env</span><span style="color: #797593">[</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">].</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">),</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">2</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">        results </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">subexp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">subexp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">        results</span><span style="color: #797593">[</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>增加了两个方法<code>initialize</code>以及<code>eval</code>。</p>
<blockquote>
<p><code>initialize</code>方法是Ruby的对象的构造器方法，即<code>new</code>对象时候会调用该方法，该方法可以省略，我们之前<code>parser</code>部分就不需要构造方法，所以就一直没有<code>initialize</code>。</p>
</blockquote>
<blockquote>
<p>Ruby中<code>@</code>开头的变量是<code>实例变量instance variable</code>，作用范围为单个对象实例内，所有该对象的内部方法都可以访问到。<br />
另外<code>@@</code>两个at符号开头是<code>类变量class variable</code>，顾名思义即同一个类创建的所有对象实例
都共享同一个类变量。<br />
Ruby<strong>不需要提前声明variable</strong>，赋值一个之前不存在的variable，会自动创建该variable。</p>
</blockquote>
<p>其中<code>initialize</code>方法中，定义了一个<code>@env</code>实例变量，并赋值了一个hash。之前说过，在Racket中代数运算看作函数，metalanguage(Ruby)实现了<code>+</code>和<code>*</code>各自对应的lambda（或者叫Proc
object，ruby的术语），lambda可以看作匿名函数，该匿名函数接受两个参数<code>x``y</code>，将其相加或者相乘。</p>
<p>后文还会详细介绍lambda，因为我们也要实现Racket的lambda，Racket和Ruby的lambda基本是同一个东西，仅语法有区别。</p>
<p>eval方法依旧含有recursive call，递归很适合处理嵌套形式，处理
子表达式<em>subexpression</em>，需要返回的情形结果可能有差异。</p>
<ul>
<li>第一个if条件分支，判断如果表达式只是纯粹数字，那么不需要额外处理，返回自身。</li>
<li>第二个条件分支，涉及expression的首个thing如果是<code>:+</code>或者<code>:*</code>，<code>env[ exp[0] ]</code>则去environment中查找对应的函数。调用传入expression紧接着的2个thing，作为两个操作数。注意此处都会先执行下eval方法，因为可能是需要处理的subexpression，同时也是使用的同样的environment。</li>
<li>最后一个条件分支，之前实现的parser实际上可以处理多个expression，例如<code>(+ 1 1) (* 2 2) (+ 3 4)</code>这样的代码中包含三个expression，parser处理完后的AST为<code>[[:+, 1, 1], [:*, 2, 2], [:+, 3, 4]]</code>，包含三个expression处理后的AST的array。即使只有一个expression，parser处理后也是一个长度为1的array，例如该章开始提到的代码，parse后的结果：<code>[ [:+ 1 [:* 2 3]] ]</code>。<br />
这里，我返回的最后一个结果。当然也可以直接放回<code>results</code>结果array。自己写的interpreter，细节由自己定义。</li>
</ul>
<h3 id="function-call以及variables-in-environment">Function
call以及Variables in environment</h3>
上面处理加和乘，可以改写成处理任何方法的通用办法.
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> updated call functions
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval_expressions</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exps</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    results </span><span style="color: #286983">=</span><span style="color: #575279"> exps</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">one_exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">one_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    results</span><span style="color: #797593">[</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span></span>
<span class="line"><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">lookup_env</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">var</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        error_no_var </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;undefined: </span><span style="color: #286983">\&quot;</span><span style="color: #EA9D34">%s</span><span style="color: #286983">\&quot;</span><span style="color: #EA9D34">&quot;</span><span style="color: #575279"> </span><span style="color: #286983">%</span><span style="color: #575279"> var</span></span>
<span class="line"><span style="color: #575279">        val </span><span style="color: #286983">=</span><span style="color: #575279"> env</span><span style="color: #797593">[</span><span style="color: #575279">var</span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> val</span><span style="color: #797593">.</span><span style="color: #575279">nil?</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">raise</span><span style="color: #575279"> error_no_var</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> val</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Numeric</span></span>
<span class="line"><span style="color: #575279">        exp </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> is a number(integer and float) return itself</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Symbol</span></span>
<span class="line"><span style="color: #575279">        lookup_env</span><span style="color: #797593">(</span><span style="color: #575279">env</span><span style="color: #797593">,</span><span style="color: #575279"> exp</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">        operator </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> first thing of s-expression sequence.</span></span>
<span class="line"><span style="color: #575279">        operands </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">].</span><span style="color: #575279">map </span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">sub_exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">sub_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> the rest things of sequence</span></span>
<span class="line"><span style="color: #575279">        operator</span><span style="color: #797593">.</span><span style="color: #575279">call </span><span style="color: #286983">*</span><span style="color: #575279">operands</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>将处理多个expression的办法提炼成<code>eval_expressions</code>方法。这样的话parse处理完后的AST(结果都是array，一个或多个expression)就先调用<code>eval_expressions</code>处理。而<code>eval</code>只用来处理单个expression。这样处理的理由，如果包含在<code>eval</code>一个条件分支的话，会与单个expression处理混乱（因为同样使用array来存放s-expression）。</p>
<p><code>else</code>分支就是处理方法调用，expression第一个thing也执行了<code>eval</code>。这样就可以处理这样的<code>( (if #t + *) 2 3 )</code>Racket代码（第一个thing也可能是sub
expresion）。</p>
<blockquote>
<p><code>operator.call *operands</code>中<code>oprands</code>是array，其前面<code>*</code>是<code>splat operator</code>。作用是将数组拆开，每个元素对应到单个参数。反过来，在函数参数声明时候也可以使用<code>*</code>，作用也是相反的，将传入的单个参数值组成array。</p>
</blockquote>
<p>另外，多了处理symbol
atom的步骤，一般symbol为variable的时候，就需要到environment查找对应的value，即<code>lookup_env</code>方法。该方法很简单，就是通过variable作为key查找environment对应的值，没有variable的话就抛出一个简单错误提示该variable没被定义。</p>
如果完整代数运算，除法和减法<code>:/</code>，<code>:-</code>可以类似上面写法。但是重复劳动了，用程序来做重复的事。另外还有一点需要改进，Racket中代数运算符，可以接受多个数字，进行累积运算。<br />
例如<code>(+ 1 4 5 7)</code>执行结果为<code>17</code>，<code>(* 2 3 4)</code>执行结果为<code>24</code>。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> updated algebra
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279; font-style: italic">ALGEBRA_OPERATORS</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[:</span><span style="color: #286983">+</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">-</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">*</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">/</span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">()</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">{</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #56949F">ALGEBRA_OPERATORS</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">opt</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">[</span><span style="color: #575279">opt</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #286983">*</span><span style="color: #575279; font-style: italic">operands</span><span style="color: #797593">|</span><span style="color: #575279"> operands</span><span style="color: #797593">.</span><span style="color: #575279">inject</span><span style="color: #797593">(</span><span style="color: #575279">opt</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>改写成上述代码，通过程序往environment增加每个代数运算符对应的lambda函数。看到这似乎炫技嫌疑，但实际后面也有相同的思想的实现，比较大小的comparison
operator也是类似的（也是能接受多个参数）</p>
<p>至此<code>eval</code>的大致结构功能如此。后文涉及的新的Racket
feature，就是往<code>eval</code>增加更多情况的处理，方式可能是增加条件分支，也有可能是往environment中增加函数（可以看作Racket自带的函数）。</p>
<h3 id="工具repl-read-eval-print-loop">工具REPL,
Read-Eval-Print-Loop</h3>
在继续完备eval方法之前，首先实现REPL这个工具，让调试Racket代码更加方便。就如之前执行Ruby代码的<code>irb</code>。
REPL全称read-eval-print-loop顾名思义，其过程: 读取code -&gt;
eval求值这段代码 -&gt; 输出结果 -&gt; 循环上述步骤。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> REPL
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">repl</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">prompt</span><span style="color: #286983">=</span><span style="color: #EA9D34">&#39;RacketOnRb &gt;&gt;&#39;</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">output_prompt</span><span style="color: #286983">=</span><span style="color: #EA9D34">&quot;=&gt;&quot;</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">while</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #B4637A; font-style: italic">print</span><span style="color: #575279"> prompt</span></span>
<span class="line"><span style="color: #575279">        code </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">gets</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">begin</span></span>
<span class="line"><span style="color: #575279">            ast </span><span style="color: #286983">=</span><span style="color: #575279"> parse</span><span style="color: #797593">(</span><span style="color: #575279">code</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">            result </span><span style="color: #286983">=</span><span style="color: #575279"> eval_expressions</span><span style="color: #797593">(</span><span style="color: #575279">ast</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #B4637A; font-style: italic">puts</span><span style="color: #575279"> output_prompt </span><span style="color: #286983">+</span><span style="color: #575279"> result</span><span style="color: #797593">.</span><span style="color: #575279">to_s</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">rescue</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">Exception</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> e</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #B4637A; font-style: italic">puts</span><span style="color: #575279"> e</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>相当直接的代码，一个无限循环，接受console输入Racket代码，然后解析执行代码，即之前描述的过程。<br />
执行<code>parse</code>，<code>eval</code>这部分时，会尝试捕获异常，如果有异常只是打印出来，继续loop。这样就能避免出错整个program终止，需要重新执行该repl方法。</p>
<h3 id="定义变量variable">定义变量variable</h3>
前面已经完成查询variable对应的value的方法。相应我们需要实现定义变量，其语法<code>(define &lt;var&gt; &lt;exp&gt;)</code>。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">define</span></span>
<span class="line"><span style="color: #575279">    _</span><span style="color: #797593">,</span><span style="color: #575279"> var</span><span style="color: #797593">,</span><span style="color: #575279"> value_exp </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"><span style="color: #575279">    env</span><span style="color: #797593">[</span><span style="color: #575279">var</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> value_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env </span><span style="color: #797593">)</span></span></code></pre>
</figure>
<p>放置于处理function call分支之前即可。</p>
<h3 id="条件判断if语句">条件判断、if语句</h3>
<p>Racket中用<code>#t</code>和<code>#f</code>表示true和false。</p>
Racket
if的语法：<code>(if &lt;test-exp&gt; &lt;then-exp&gt; &lt;else-exp&gt;)</code>当<test-exp>执行结果不是<code>#f</code>的时候，执行<code>&lt;then-exp&gt;</code>分支，否则执行<code>&lt;else-exp&gt;</code>分支
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">{</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">:&#39;</span><span style="color: #286983">#t</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span><span style="color: #797593">,</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">:&#39;</span><span style="color: #286983">#f</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span></span>
<span class="line"><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ...</span></span>
<span class="line"><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">if</span></span>
<span class="line"><span style="color: #575279">    _</span><span style="color: #797593">,</span><span style="color: #575279"> test_exp</span><span style="color: #797593">,</span><span style="color: #575279"> then_exp</span><span style="color: #797593">,</span><span style="color: #575279"> else_exp </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">test_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> else_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env </span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> other than false(#f)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> then_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>ruby注释使用<code>#</code>，如果symbol含有#的话，需要用引号括起来。这里会把Racket的<code>#t #f</code>转化为Ruby中的true和false。</p>
<h3 id="比较操作comparison-operators">比较操作comparison operators</h3>
至于比较操作，上文提过了类似代数操作实现。
当有多个需要比较的对象时，比较操作需要两两比较，所有两两比较结果为true，则返回true，否则false。
<code>each_cons(n)</code>就是(Ruby提供方法来遍历连续<em>consecutive</em>的n个元素)。<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> comparision
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279; font-style: italic">COMPARISION</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[:</span><span style="color: #286983">==</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">!=</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&lt;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&gt;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&lt;=</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&gt;=</span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">()</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ...</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #56949F">COMPARISION</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">opt</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">[</span><span style="color: #575279">opt</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #286983">*</span><span style="color: #575279; font-style: italic">args</span><span style="color: #797593">|</span><span style="color: #575279"> args</span><span style="color: #797593">.</span><span style="color: #575279">each_cons</span><span style="color: #797593">(</span><span style="color: #D7827E">2</span><span style="color: #797593">).</span><span style="color: #575279">all? </span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">y</span><span style="color: #797593">|</span><span style="color: #575279"> x</span><span style="color: #797593">.</span><span style="color: #575279">method</span><span style="color: #797593">(</span><span style="color: #575279">opt</span><span style="color: #797593">).</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279">y</span><span style="color: #797593">)}</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>Ruby和其他大部分语言，使用<code>=</code>代表赋值操作，所以比较是否相等时候使用<code>==</code>。但是Racket有专门的<code>define</code>操作，所以依旧使用<code>=</code>代表比较是否相等的函数。<br />
我追求简单，所以实现套用Ruby语法。如果要改为Scheme
Racket语法也很简单，多做一次符号映射即可，其他不做赘述了。</p>
<h3 id="cons-cell-and-list">Cons Cell and List</h3>
<p><code>cons</code>操作用来构建一个pair，其通过<code>car</code>获得pair的第一个数据，通过<code>cdr</code>获得pair的第二个数据，pair有专门的术语：<code>cons cell</code>。</p>
<p>另外Racket有个特许且常用的<code>cons cell</code>形式：<code>list</code>，例如<code>(cons 1 (cons 2 (cons 3 (cons 4 null))))</code>代码，nested
cons
cells，最后一个（最内部的pair）的第二数据以<code>null</code>为结尾。<br />
<code>null</code>在Racket中代表空list，<code>null?</code>判断是否为空的函数。list有个更加简便的写法<code>(list 1 2 3 4)</code>等同上行的代码例子。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 40%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Primitive</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">null</td>
<td style="text-align: left;">The empty list</td>
<td style="text-align: left;">null</td>
</tr>
<tr class="even">
<td style="text-align: left;">cons</td>
<td style="text-align: left;">Construct a list</td>
<td style="text-align: left;">(cons 2 (cons 3 null))</td>
</tr>
<tr class="odd">
<td style="text-align: left;">car</td>
<td style="text-align: left;">Get rst element of a list</td>
<td style="text-align: left;">(car some-list)</td>
</tr>
<tr class="even">
<td style="text-align: left;">cdr</td>
<td style="text-align: left;">Get tail of a list</td>
<td style="text-align: left;">(cdr some-list)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">null?</td>
<td style="text-align: left;">Return #t for the empty-list and #f
otherwise</td>
<td style="text-align: left;">(null? some-value)</td>
</tr>
</tbody>
</table>
<p>对于Ruby实现代码，我们使用array来存放<code>cons cells</code>，固定两个元素。</p>
<p>对于<code>list</code>函数实现，依旧采用recursion方式，cons（直接构造Ruby
array）第一个参数以及余下参数构成的list，很直白实现方式。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> cons cells
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #797593">:</span><span style="color: #286983">null?</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">null</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> exp </span><span style="color: #797593">},</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> racket empty list.</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">cons</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">cell</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #797593">[</span><span style="color: #575279">x</span><span style="color: #797593">,</span><span style="color: #575279"> cell</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">},</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">car</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">cell</span><span style="color: #797593">|</span><span style="color: #575279"> cell</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]},</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">cdr</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">cell</span><span style="color: #797593">|</span><span style="color: #575279"> cell</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">},</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">list</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #286983">*</span><span style="color: #575279; font-style: italic">args</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> racket code &#39;(list 1 2 3)&#39; is equivalent to &#39;(cons 1 (cons 2 (cons 3 null)))&#39;</span></span>
<span class="line"><span style="color: #575279">    racket_list_helper</span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">args</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> args</span><span style="color: #797593">.</span><span style="color: #575279">empty? </span><span style="color: #286983">then</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">null</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593">[</span><span style="color: #575279">args</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">],</span><span style="color: #575279"> racket_list_helper</span><span style="color: #797593">.</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279">args</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">])]</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    racket_list_helper</span><span style="color: #797593">.</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279">args</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<!-- TODO: map, filter, fold -->
<h3 id="functionslambda-and-apply">Functions，Lambda and Apply</h3>
<!-- pullquote "has-quotes"  endpullquote  TODO: pullquote style  -->
<blockquote>
<p>问题弄清楚后，答案自然就清楚了。</p>
</blockquote>
<p>到了我觉得最重要的function部分了。目标实现function，只需要搞清楚何为function就知道如何实现，首先先要明确一些相关的概念。</p>
<p>Racket的函数遵循<code>lexical scope</code>又称作<code>static scope</code>，函数的正文部分求值时，所用的environment在该函数被定义时候的enviroment。相对立的<code>dynamic scope</code>，就是函数求值时，使用的函数被调用的enviroment。</p>
<blockquote>
<p>The body of function is evaluated in the environment when the
function is <strong>defined</strong>, not the environment when the
function is <strong>called</strong>.</p>
</blockquote>
<p>现在主流编程语言基本都是使用<code>lexical scope</code>，程序行为更可控。</p>
<p>除了定义的时候的environment，方法执行的时候，还会将该environment扩展添加参数<em>parameters</em>以及其对应传入的值<em>arguments</em>。</p>
<p>function(或者叫lambda,
procedure)的实现代码如下，存放lambda的parameters和body，以及定义时候的envrioment，就如同上文描述那样。</p>
<p>定义了Closure
class，只是用来存放closure的值。也可以用数组<code>[:closure, parameters, body, env]</code>存放，通过index取值，但是这样的话<code>:closure</code>可以被覆盖。</p>
<p>真正执行部分，处于之前执行方法部分，之前处理例如加法之类的primitive
procedures。现在增加分支专门处理，用户定义的函数<em>compound
procedures</em>。
操作数部分与之前一样，先eval，然后补充进函数定义时的environment。该environment为执行函数体<em>body</em>的环境，然后求值。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> closure
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">class</span><span style="color: #575279"> </span><span style="color: #56949F">Closure</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">attr_reader</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">parameters</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">body</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">env</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">parameters</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">body</span><span style="color: #575279"> ,</span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">parameters</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> parameters</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">body</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> body</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> env</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other part code</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">lambda</span></span>
<span class="line"><span style="color: #575279">        _</span><span style="color: #797593">,</span><span style="color: #575279"> parameter_names</span><span style="color: #797593">,</span><span style="color: #575279"> fun_body </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #56949F">Closure</span><span style="color: #797593">.</span><span style="color: #286983">new</span><span style="color: #797593">(</span><span style="color: #575279">parameter_names</span><span style="color: #797593">,</span><span style="color: #575279"> fun_body</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other part code</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> call function</span></span>
<span class="line"><span style="color: #575279">        operator </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> first thing of s-expression sequence.</span></span>
<span class="line"><span style="color: #575279">        operands </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">].</span><span style="color: #575279">map </span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">sub_exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">sub_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> the rest things of sequence</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Closure</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> compounded procedures(user-defined)# extends environment with parameters and their actual arguments applied.</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">            env_fn </span><span style="color: #286983">=</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">parameters</span><span style="color: #797593">.</span><span style="color: #575279">zip</span><span style="color: #797593">(</span><span style="color: #575279">operands</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #286983">+</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">env</span></span>
<span class="line"><span style="color: #575279">            body </span><span style="color: #286983">=</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">body</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">body</span><span style="color: #797593">,</span><span style="color: #575279"> env_fn</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> primitive operators</span></span>
<span class="line"><span style="color: #575279">            operator</span><span style="color: #797593">.</span><span style="color: #575279">call </span><span style="color: #286983">*</span><span style="color: #575279">operands</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>另外environment有了较大的改动，之前使用hash结构，在写这篇文章的时候，我重新审查代码时候，发现有较大缺陷：</p>
<ul>
<li>之前hash结构，define定义新变量是直接更改该hash本身，mutation操作。定义lambda的时候，最初直接传入env本身，然而因为hash是可变的，所以实现的是<code>dynamic scope</code>方式，后续对env操作也会影响函数定义是当前的env(就是同一个对象)。</li>
<li>我最初的处理方法是，对于函数定义时候的env，使用一个新的对象<code>env.clone</code>。似乎解决了问题，但是在某些simultaneous同时发生，比如需要两个方法同时定义，如果通过<code>env.clone</code>，两个方法的env是两个独立对象，然而我们需要两个方法env都是同一个对象，因为它们处于并列状态，例如<code>letrec</code>（不是本文重点，但代码中有实现）。</li>
</ul>
<p>所以，需要改变的是：</p>
<ul>
<li>define添加新的variable到当前env（并不改变原先env）作为新的env。相当于新的environment是immutable。</li>
<li>定义lambda的时候，直接使用当前的env。</li>
</ul>
<figure>
<img src="/assets/images/2017-RacketOnRuby/closure-env.jpg"
alt="the environment of the closure" />
<figcaption aria-hidden="true">the environment of the
closure</figcaption>
</figure>
<p>对应到ruby代码实现。使用array取代hash，其中每个元素即变量和其对应的值（2个元素的array分别存variable,value）。
define时候通过 <code>env[0..-1]</code>
重新赋值env。由于现在需要直接更改当前的environment，而且ruby不支持参数传入引用，所以我使用<code>env[0..-1] = [new array]</code>将env内的array中的元素替换成新的env（包含新定义的variable），来达到更改当前environment目的。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> new environment
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">[:&#39;</span><span style="color: #286983">#t</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">,</span><span style="color: #575279">  </span><span style="color: #D7827E">true</span><span style="color: #797593">],</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">[:&#39;</span><span style="color: #286983">#f</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">,</span><span style="color: #575279">  </span><span style="color: #D7827E">false</span><span style="color: #797593">],</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> Racket &#39;not&#39; operator if exp is #f, results #t. otherwise false. it differents from ruby not</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">[:</span><span style="color: #286983">not</span><span style="color: #575279"> </span><span style="color: #797593">,</span><span style="color: #575279">  </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span><span style="color: #286983">==</span><span style="color: #575279">exp </span><span style="color: #286983">then</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span><span style="color: #575279"> </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span><span style="color: #575279"> </span><span style="color: #286983">end</span><span style="color: #575279"> </span><span style="color: #797593">}],</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other primitive procedures.</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">lookup_env</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">var</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        error_no_var </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;undefined: %s !&quot;</span><span style="color: #575279"> </span><span style="color: #286983">%</span><span style="color: #575279"> var</span></span>
<span class="line"><span style="color: #575279">        var_val </span><span style="color: #286983">=</span><span style="color: #575279"> env</span><span style="color: #797593">.</span><span style="color: #575279">assoc var</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> var_val</span><span style="color: #797593">.</span><span style="color: #575279">nil?</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">raise</span><span style="color: #575279"> error_no_var</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">elsif</span><span style="color: #575279"> var_val</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">UNASSIGNED_VAL</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">raise</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;the unassigned value should not be access.&quot;</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> var_val</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other eval parts</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">define</span></span>
<span class="line"><span style="color: #575279">        _</span><span style="color: #797593">,</span><span style="color: #575279"> var</span><span style="color: #797593">,</span><span style="color: #575279"> value_exp </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        value </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> value_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env </span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        env</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[[</span><span style="color: #575279">var </span><span style="color: #797593">,</span><span style="color: #575279"> value</span><span style="color: #797593">]]</span><span style="color: #575279"> </span><span style="color: #286983">+</span><span style="color: #575279"> env</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other eval parts</span></span>
<span class="line"><span style="color: #286983">end</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> eval</span></span></code></pre>
</figure>
<p>至此，最重要的lambda部分就已经完成实现了。</p>
<h2 id="racketonruby总结">RacketOnRuby总结</h2>
<p>出于练习目的，实现Racket的一个解析器。从功能完整性和性能考虑，并不适合实际生产中运用。</p>
<p>得益于Racket语法统一简单，实现也相对简单。不像很多别的语言，有大量不同形式的语法。</p>
<ul>
<li>相对于原生Racket，肯定缺少一些功能，但常见的基本都实现了。
<ul>
<li>实现了environment、variable、condition(if)、 lambda、 cons cells、
list、 一些primitive procedures(代数运算，数值比较)。</li>
<li>语法缺少的：注释<em>comment</em>、 quote、 # symbol(字面量类似Ruby
symbol)、 一些derived
expression(可以转化为现有的别的表达式，例如cond用来多个条件判断，可以转化为嵌套的if)</li>
<li>项目中代码是实现有<code>let</code>和<code>letrec</code>，也是derived
expression。<code>(let ([&lt;var&gt; &lt;exp&gt;]) body)</code>其作用就是绑定local
variable，并在其environment执行body部分代码。<code>let</code>可以转为<code>lambda</code>,
<code>letrec</code>可以转为一种特殊形式<code>let</code>。转化方法是直接操作AST，由于Ruby中AST用的Array表现，并不是那么清晰，所以不做本文重点。（相对于metalanguage使用Lisp系语言，Lisp系语言code即data，代码部分也可以操作，即可以直接在程序expression上直接操作）</li>
<li>缺少大量primitive
procedures，语言肯定会有大量自带的函数，不可能一一实现。其中之一就是mutation
list，Racket的默认list是不可变的immutable。如果需要可变的，有专门的操作:<code>mcons</code>，<code>set-mcar!</code>,
<code>set-mcdr!</code>。这一点也是Racket与Scheme不同的一处，Scheme中list是mutation
list。</li>
<li>error
handling不是主要目标，所以几乎没有异常错误处理，所以需要执行的program先要保证正确的。可以DrRacket先执行一遍，尤其括号方面（多或者少，不匹配），IDE可以很明显看出括号范围。</li>
</ul></li>
<li>性能方面，也不是主要目标，没有特别优化。下面指出一些可以改进的地方：
<ul>
<li><code>eval</code>实现，实际上语义分析<em>syntactic
analysis</em>夹杂在执行<em>execution</em>之中，不是有效率的做法。如下阶乘的program，当执行<code>(factorial 5)</code>，递归调用<code>factorial</code>多次，其中<code>if</code>部分每次都需要判断出是<code>if</code>，但执行到<code>(* (factorial (- n 1)) n)))</code>其中<code>(- n 1)</code>和<code>(factorial (- n 1))</code>都需要在<code>eval</code>判断出是方法执行然后再处理。非常重复浪费的做法，需要将analysis分离出来，本文并没涉及，具体实现可以参考SICP<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>第四大章中<em>Separating Syntactic
Analysis from Execution</em>小节部分
<figure class="highlight code-block">
<figcaption>
<span class="language">scheme</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279">    </span><span style="color: #797593">(</span><span style="color: #286983">define</span><span style="color: #575279"> </span><span style="color: #797593">(</span><span style="color: #D7827E">factorial</span><span style="color: #907AA9; font-style: italic"> n</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593">(</span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #797593">(</span><span style="color: #286983">=</span><span style="color: #575279"> n </span><span style="color: #D7827E">1</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #D7827E">1</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #797593">(</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #797593">(</span><span style="color: #575279">factorial </span><span style="color: #797593">(</span><span style="color: #286983">-</span><span style="color: #575279"> n </span><span style="color: #D7827E">1</span><span style="color: #797593">))</span><span style="color: #575279"> n</span><span style="color: #797593">)))</span></span></code></pre>
</figure></li>
<li>缺少<code>TCO</code><em>tail call
optimization</em>，尾递归优化，Lisp和Scheme系的语言program非常依赖与递归调用，TCO非常重要，能省去很多function
call占用的stack空间。</li>
</ul></li>
</ul>
<p>要想了解interpreter如何工作，最好办法就是自己实现一个了，这就是我实现RacketOnRuby以及写本文的目的。
如果需要更深入了解，推荐上文提及SICP以及另外一本书TSPL<a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>，都是有免费阅读的电子版。或者自行搜索，有相当多的资料。</p>
<p>另外文章最开始提及的《黑客与画家》，非编程技术书，也推荐阅读。语言通俗易懂，不涉及技术细节，阅读不费力，非程序员也能读。但其中作者的思想条理清晰，观点深入透彻。另外本书也不光全是关于Lisp，还有一些有趣事情，我印象较深的就是最开始的章节”为什么书呆子不受欢迎”。</p>
<p>{# &gt; The prefixes <code>#b</code>, <code>#o</code>, and
<code>#x</code> specify binary, octal, and hexadecimal interpretation of
digits</p>
<h4
id="implemention-on-racket-environment-using-cons-benifit-sharing-small-part-due-to-immutation">implemention
on Racket environment using cons (benifit sharing small part due to
immutation)</h4>
<p>#}</p>
<!-- toc -->
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://ruby-doc.org/core-2.4.0/String.html#method-i-split">Ruby
Doc: String.split</a>: If pattern is a String, then its contents are
used as the delimiter when splitting str. If pattern is <strong>a single
space</strong>, str is split on <strong>whitespace</strong>, with
leading whitespace and runs of <strong>contiguous whitespace characters
ignored</strong>.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-each_cons">Ruby
Doc Enumerable each_cons(n)</a>: Iterates the given block for each array
of consecutive <n> elements. If no block is given, returns an
enumerator.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><em>Structure and Interpretation of Computer
Programs</em> <a
href="https://mitpress.mit.edu/sicp/full-text/book/book.html">MIT
scheme课程书籍</a>. <a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><em>The Scheme Programming Language</em> <a
href="http://www.scheme.com/tspl4/">http://www.scheme.com/tspl4/</a>. <a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content><author><name></name></author><category term="programming" /><category term="interpreter" /><category term="racket" /><category term="ruby" /><category term="lambda" /><category term="scheme" /><category term="lisp" /><category term="eval" /><summary type="html"><![CDATA[如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器interpreter来练个手。 我学的是 Lisp(或者说Scheme) 方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。 毕竟之前也接触过很多语言，基本都是学的语言特性feature，和其流行的package使用(比如web框架)。很少接触过语言实现language implemention的知识。 当自己能写出解释器的时候，感觉到一种新的学习语言的体验。 这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。 项目github链接：https://github.com/mixflow/RacketOnRuby/]]></summary></entry><entry><title type="html">UE4 Work - Simple Bookroom</title><link href="https://www.mix-flow.com/works/ue4/2017/02/18/UE4-work-book-room.html" rel="alternate" type="text/html" title="UE4 Work - Simple Bookroom" /><published>2017-02-18T01:53:21+08:00</published><updated>2017-02-18T01:53:21+08:00</updated><id>https://www.mix-flow.com/works/ue4/2017/02/18/UE4-work-book-room</id><content type="html" xml:base="https://www.mix-flow.com/works/ue4/2017/02/18/UE4-work-book-room.html"><![CDATA[<p>Rendering in Unreal Engine 4 and modeling in Blender.</p>
<p>This is my first project in UE4 which was rendered in early
2016.<br />
Before this, I had mostly learned the programming concepts of UE4, such
as gaming AI, which has no graphical representation.</p>
<figure>
<img src="/assets/images/2016-BookRoom/1.jpg"
alt="Overview in front room" />
<figcaption aria-hidden="true">Overview in front room</figcaption>
</figure>
<blockquote>
<p>Updated on March 13, 2023</p>
<p>In 2016, when I was using the older version of Unreal Engine
4(specifically 4.09 or 4.10), I encountered two common problems with the
default <strong>lightmass</strong> lighting method:</p>
<ol type="1">
<li>The shelves had lighting black spots caused by the wrong hand-made
<strong>lightmap</strong> UVs.</li>
<li>The indoor lighting wasn’t bright enough, I had to increase the
exposures dramatically to solve this(alought this is not a recommended
solution).</li>
</ol>
<p>Nowadays, with Unreal Engine 5, there is no need to consider these
problems anymore because of the new lighting system called
<strong>lumen</strong>.</p>
</blockquote>
<!--more-->
<figure>
<img src="/assets/images/2016-BookRoom/2.jpg" alt="Sofa chair" />
<figcaption aria-hidden="true">Sofa chair</figcaption>
</figure>
<figure>
<img src="/assets/images/2016-BookRoom/3.jpg" alt="Sideview" />
<figcaption aria-hidden="true">Sideview</figcaption>
</figure>
<figure>
<img src="/assets/images/2016-BookRoom/4.jpg" alt="Desk" />
<figcaption aria-hidden="true">Desk</figcaption>
</figure>
<figure>
<img src="/assets/images/2016-BookRoom/5.jpg" alt="Windows" />
<figcaption aria-hidden="true">Windows</figcaption>
</figure>
<figure>
<img src="/assets/images/2016-BookRoom/6.jpg"
alt="Shelves and canvas" />
<figcaption aria-hidden="true">Shelves and canvas</figcaption>
</figure>
<figure>
<img src="/assets/images/2016-BookRoom/7.jpg"
alt="Overview in bookroom" />
<figcaption aria-hidden="true">Overview in bookroom</figcaption>
</figure>
<figure>
<img src="/assets/images/2016-BookRoom/8.jpg" alt="Stairs" />
<figcaption aria-hidden="true">Stairs</figcaption>
</figure>]]></content><author><name></name></author><category term="works" /><category term="ue4" /><category term="UE4" /><category term="unreal engine" /><category term="work" /><category term="interior" /><category term="blender" /><category term="PBR" /><category term="3D" /><category term="CG" /><summary type="html"><![CDATA[Rendering in Unreal Engine 4 and modeling in Blender. This is my first project in UE4 which was rendered in early 2016. Before this, I had mostly learned the programming concepts of UE4, such as gaming AI, which has no graphical representation. Overview in front room Updated on March 13, 2023 In 2016, when I was using the older version of Unreal Engine 4(specifically 4.09 or 4.10), I encountered two common problems with the default lightmass lighting method: The shelves had lighting black spots caused by the wrong hand-made lightmap UVs. The indoor lighting wasn’t bright enough, I had to increase the exposures dramatically to solve this(alought this is not a recommended solution). Nowadays, with Unreal Engine 5, there is no need to consider these problems anymore because of the new lighting system called lumen.]]></summary></entry></feed>