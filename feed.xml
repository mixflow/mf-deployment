<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://www.mix-flow.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.mix-flow.com/" rel="alternate" type="text/html" /><updated>2023-03-13T15:03:40+08:00</updated><id>https://www.mix-flow.com/feed.xml</id><title type="html">MixFlow</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">A Glimpse into ChatGPT by A Conversation with ChatGPT - Machine Learning Strategy</title><link href="https://www.mix-flow.com/machine-learning-strategy/2023/02/13/A-Glimpse-into-ChatGPT-by-A-Conversation-with-ChatGPT.html" rel="alternate" type="text/html" title="A Glimpse into ChatGPT by A Conversation with ChatGPT - Machine Learning Strategy" /><published>2023-02-13T12:38:14+08:00</published><updated>2023-02-13T12:38:14+08:00</updated><id>https://www.mix-flow.com/machine-learning-strategy/2023/02/13/A-Glimpse-into-ChatGPT-by-A-Conversation-with-ChatGPT</id><content type="html" xml:base="https://www.mix-flow.com/machine-learning-strategy/2023/02/13/A-Glimpse-into-ChatGPT-by-A-Conversation-with-ChatGPT.html"><![CDATA[<blockquote>
<p>The “Machine Learning Strategy” series is a collection of articles on
the subjects of Machine Learning, Neural Networks and Artificial
Intelligence. In this series, I will share my personal experiences and
insights as I learn and understand these topics. The articles will cover
aspects such as the tools and techniques used in ML, the programming
concepts involved, and even the psychological impact of human
interaction with AI.</p>
<p>The aim is to provide both a practial and theoretical understanding
of Machine Learning. This includes exploring the applications of ML, as
well as its underlying implementation and limitations, along with
pontential areas for improvement. Both the ways in which Machine
Learning can be utilized and the potential advancement of the technology
itself Hopefully, I would offer both the application of Machine
Learning, and Machine Learning itself underlying implementation and
limits with potential improvements. This is two way of the “strategy”, a
way about usage and a way about AI itself.</p>
</blockquote>
<p>ChatGPT almost had gone viral once it released. One month ago, I
encounter the ChatGPT and check whether its ability is good as mentioned
which is a better and smarter AI.</p>
<p>Compare to the API to access GPT-3, it’s a easier and smarter way to
just have a dialoge with the AI like ordinary IM software which has no
preset after account registration.</p>
<p>I heard about ChatGPT and GPT-3, but not very much technique related.
So I decided to give a interview and let ChatGPT itself explain and
educate. <!--more--></p>
<h1 id="is-it-based-on-gpt-3---overview-of-chatgpt-model">Is it based on
GPT-3? - Overview of ChatGPT Model</h1>
<p>About years ago, I heard GPT-3 from some which is also developed by
OpenAI. I had been not sure about whether the ChatGPT is based on GPT-3
or another totally different approach. So I just start with the question
“is ChatGPT based on GPT-3?”. It confirms that the archeitecture and
trainning data are total unique from the GPT-3.</p>
<p>It’s also a deep neural network model which doesn’t have a specify
name, but it belongs to a larger system called “Assistant”. According to
the reply from ChatGPT, the “Assistant” system can do a bunch of
different types of tasks, includes the language model which exactly is
the ChatGPT and speech recognition and image processing and more.</p>
<h1 id="details-of-the-language-model">Details of The Language
Model</h1>
<p>Language model would process and generate the text. I also asked
ChatGPT to cover more techinial information.</p>
<p>Basicly it’s a variant of the <strong><em>Transformer</em></strong>
architecture that is a neural network for tasks of
<strong><em>NLP</em></strong>(<strong><em>natural language
processing</em></strong>). The process is literally to <strong>predict
the next word in a sequence, given the previous words</strong>, which is
called as <strong><em>Masked Language Modeling</em></strong>.</p>
<p>ChatGPT is also based on <strong><em>self-attention</em></strong>
which allows the model to weight the importance of different input words
of a given sequence of text.</p>
<h2 id="comparison-to-long-short-term-memory-model">Comparison to Long
Short-term Memory Model</h2>
<p>After read the explaination from ChatGPT. I realized that it is quite
similar to <strong><em>LSTM</em></strong>(<strong><em>Long Short-term
Memory</em></strong>) model and discussed this topic in serval
questions.</p>
<p>Main difference is the implementation to preserve the input
information. LSTM use memory cell instead ChatGPT use
<strong><em>self-attention</em></strong></p>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/93/LSTM_Cell.svg/450px-LSTM_Cell.svg.png"
alt="Long Short-term Memory cell can process data sequentially and keep its hidden state through time. From wikipedia" />
<figcaption aria-hidden="true">Long Short-term Memory cell can process
data sequentially and keep its hidden state through time. From <a
href="https://en.wikipedia.org/wiki/Long_short-term_memory">wikipedia</a></figcaption>
</figure>
<p>self-attention calculate the weight of the the importance of each
word in the input sequence. I wouldn’t show the technique which I
thought was not intuitive, You can also search another term “Q,K,V”
which are the vectors to use in the calculation and excatly the
self-attention part.</p>
<h1 id="languages---the-training-data">Languages - The Training
data</h1>
<p>// the main language is English // train multiple languages at the
same time</p>]]></content><author><name></name></author><category term="Machine-Learning-Strategy" /><category term="ML" /><category term="Machine Learning" /><category term="AI" /><category term="Artificial Intelligence" /><category term="Neural Network" /><category term="NLP" /><category term="Natural Language Processing" /><category term="ChatGPT" /><category term="OpenAI" /><category term="GPT" /><category term="Generative Pre-trained Transformer" /><category term="GPT-3" /><category term="LSTM" /><category term="Long Short-Term Memory Model" /><category term="Machine Learning Strategy" /><category term="Machine Learning Strategy series" /><summary type="html"><![CDATA[The “Machine Learning Strategy” series is a collection of articles on the subjects of Machine Learning, Neural Networks and Artificial Intelligence. In this series, I will share my personal experiences and insights as I learn and understand these topics. The articles will cover aspects such as the tools and techniques used in ML, the programming concepts involved, and even the psychological impact of human interaction with AI. The aim is to provide both a practial and theoretical understanding of Machine Learning. This includes exploring the applications of ML, as well as its underlying implementation and limitations, along with pontential areas for improvement. Both the ways in which Machine Learning can be utilized and the potential advancement of the technology itself Hopefully, I would offer both the application of Machine Learning, and Machine Learning itself underlying implementation and limits with potential improvements. This is two way of the “strategy”, a way about usage and a way about AI itself. ChatGPT almost had gone viral once it released. One month ago, I encounter the ChatGPT and check whether its ability is good as mentioned which is a better and smarter AI. Compare to the API to access GPT-3, it’s a easier and smarter way to just have a dialoge with the AI like ordinary IM software which has no preset after account registration. I heard about ChatGPT and GPT-3, but not very much technique related. So I decided to give a interview and let ChatGPT itself explain and educate.]]></summary></entry><entry><title type="html">Blender Cycles渲染作品 面包圈</title><link href="https://www.mix-flow.com/my%20work/blender/cycles/2017/04/02/blender-cycles-render-donuts.html" rel="alternate" type="text/html" title="Blender Cycles渲染作品 面包圈" /><published>2017-04-02T02:27:54+08:00</published><updated>2017-04-02T02:27:54+08:00</updated><id>https://www.mix-flow.com/my%20work/blender/cycles/2017/04/02/blender-cycles-render-donuts</id><content type="html" xml:base="https://www.mix-flow.com/my%20work/blender/cycles/2017/04/02/blender-cycles-render-donuts.html"><![CDATA[<ul>
<li>制作软件: blender</li>
<li>渲染软件: blender cycles</li>
</ul>
<p>这个是我最初接触3D制作，其中一个跟着教程做的作品。教程来自<a
href="http://www.blenderguru.com/">blenderguru</a>（英文）。</p>
<p>最初做完并没有下图的水准。直到最近发现了一个针对blender
cycles的改进，就拿这个当年练手作品试验了下，质量大幅度提升。（之后可能会写篇文章介绍）</p>
<p>个人非常满意现在的效果：</p>
<figure>
<img src="" class="b-lazy" data-src="/images/2017-Donuts/result1.jpg"
alt="主视角" />
<figcaption aria-hidden="true">主视角</figcaption>
</figure>
<!-- more -->
<figure>
<img src="" class="b-lazy" data-src="/images/2017-Donuts/result2.jpg"
loading="lazy"
alt="俯视 并不是专门设计的视角，只是为了从另一个角度查看" />
<figcaption aria-hidden="true">俯视
并不是专门设计的视角，只是为了从另一个角度查看</figcaption>
</figure>
<p>上一张图亮度有些高（有点过曝的感觉），个人稍微调整了下，以便观看效果更好点。<br />
进行的操作：对比度略微调强（糖浆颜色更突出），亮度略微调低。</p>
<p><em>个人并不是专业摄影师，没有经过专门后期处理的培训，只是凭自己的感官调整差不多个人满意的效果。</em></p>
<p><img src="" alt="上张俯视效果图 后期处理" />{:class=“b-lazy”
data-src=“/images/2017-Donuts/result3.jpg” loading=“lazy”}</p>]]></content><author><name></name></author><category term="my work" /><category term="blender" /><category term="cycles" /><category term="blender" /><category term="cycles" /><category term="render" /><category term="PBR" /><category term="3D" /><category term="CG" /><summary type="html"><![CDATA[制作软件: blender 渲染软件: blender cycles]]></summary></entry><entry xml:lang="zh"><title type="html">使用Ruby写一个Racket(Scheme)解释器</title><link href="https://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby.html" rel="alternate" type="text/html" title="使用Ruby写一个Racket(Scheme)解释器" /><published>2017-02-20T13:38:05+08:00</published><updated>2017-02-20T13:38:05+08:00</updated><id>https://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby</id><content type="html" xml:base="https://www.mix-flow.com/2017/02/20/write-racket-scheme-interpreter-on-ruby.html"><![CDATA[<!-- TODO  img center '/images/symbol/lambda.svg' 200 'lambda symbol'  -->
<p>如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器<code>interpreter</code>来练个手。</p>
<p>我学的是 Lisp(或者说Scheme)
方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。<br />
毕竟之前也接触过很多语言，基本都是学的语言特性<code>feature</code>，和其流行的package使用(比如web框架)。很少接触过语言实现<code>language implemention</code>的知识。</p>
<p>当自己能写出解释器的时候，感觉到一种新的学习语言的体验。</p>
<p>这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。</p>
<p>项目github链接：<a
href="https://github.com/mixflow/RacketOnRuby/">https://github.com/mixflow/RacketOnRuby/</a>
<!--more--></p>
<h2 id="语言相关介绍">语言相关介绍</h2>
<p>Ruby现在还算有些名声，现在的程序员即使没用过的，可能都知道有这门语言。<br />
但是Lisp Scheme可能很多程序员都没听说过，
我当年阅读了别人推荐的《黑客与画家》
这本书才有所了解，在此之前我似乎连Lisp或者Scheme的名字都没见过。
所以有必要先简介一下。</p>
<h3 id="lisp-scheme-racket-是什么">Lisp Scheme Racket 是什么?</h3>
<p>Lisp是一门诞生于上个世纪50年代的语言。其后有很多相同思想的语言，都算得上Lisp家族的，一般被称为Lisp
方言<code>dialect</code>， 其中就包括这里提及的另外两个语言Racket
Scheme。Scheme年代更加久远，影响也大些。Racket相比之下更年轻些。</p>
<p>这篇文章只涉及语言基本简单特征实现，这块哪怕语法上面Racket
Scheme都没什么区别，
所以这里的Racket解释器也可看作Scheme解释器。也就是说能解释执行Scheme代码。</p>
<h3 id="why-use-ruby">Why use Ruby?</h3>
<ol type="1">
<li>当时正好也在学Ruby，所以就用Ruby实现下，纯练手。</li>
<li>这个是第二个编译器实现。最早第一个是当时学习Racket的时候，使用Racket本身实现的，编写了一个<code>metacirclar evaluator</code>，这种方式可以跳过<code>parse</code>步骤（详见紧接着的下文），因为写的代码就已经是AST了（依旧详见下文）。那么用Ruby来实现Racket的话，是需要<code>parser</code>，所以也能再多练一些(虽说parser也没什么复杂的)。</li>
<li>《黑客与画家》中
<em>“如果回到1975年，你声称它(Ruby)是一种有着自己语法的Lisp方言，没有人会提出反对意见。”</em>。<br />
作者认为Ruby也可以视为Lisp的一种方言。那么我反过来通过Lisp的方言来实现Lisp，想法有些古怪，但我认为有点意思。</li>
</ol>
<h2 id="实现一个编程语言通常的步骤">实现一个编程语言通常的步骤</h2>
<p>下面涉及的是一个典型的语言实现<code>language implemention</code>的流程：</p>
<ol type="1">
<li>首先接受一串字符串<code>string</code>，其内容就是用此语言编写的程序。如果该字符串不是符合语法结构<em>syntactically
well-formed</em>（比如关键字拼写错误等），分析器<code>parser</code>会报错。</li>
<li>如果没有上述的语法错误，parser会生成一个树<code>tree</code>来表示程序。这个树一般称为<code>abstract-syntax tree</code>，简称为<code>AST</code>。
<ul>
<li>如果语言有<code>类型检查 type-checking</code>或其他原因，认定AST仍然不是一个合法的程序。
<code>类型检查器 type-checker</code>就会生成错误信息。</li>
<li>如果没有上述错误, AST就会被传递给后续流程。</li>
</ul></li>
<li>实现目标编程语言<code>language B</code>的剩余流程，基本就是如下两种方案。
<ul>
<li>可以用另一门语言<code>language A</code>编写<code>解释器 interpreter</code>来接受使用<code>language B</code>编写的程序，并最终产生结果。这里用来实现interpreter的language
A，有个专门术语称呼：<code>metalanguage</code>。</li>
</ul>
<blockquote>
<p>如果把这个<code>language A</code>程序称作<code>evaluator for B</code>（evaluate中文对应术语一般叫求值，大概意思达到了，但我个人觉得不太准确）或者<code>执行器 executor for B</code>，可能会更直白些。但<code>解释器 interpreter</code>是约定俗成的术语。</p>
</blockquote>
<ul>
<li>另外一种方式再<code>language A</code>写一个<code>编译器 compiler</code>来将<code>language B</code>写的程序生成一个等价<em>equivalent</em>
<code>language C</code>的程序。
然后再使用早已存在的<code>language C</code>语言实现。</li>
</ul>
<blockquote>
<p><code>编译器 compiler</code>可能称为<code>翻译器 translator</code>更好，与interpreter同样的原因，compiler是个普遍使用的术语。</p>
</blockquote></li>
</ol>
<figure>
<img
src="https://upload.wikimedia.org/wikipedia/commons/d/d6/Parser_Flow%D5%B8.gif"
alt="implementing program language workflow from wikipedia parsing" />
<figcaption aria-hidden="true">implementing program language workflow
from <a href="https://en.wikipedia.org/wiki/Parsing">wikipedia
parsing</a></figcaption>
</figure>
<p>另外要说教下，编译器以及解释器只是<strong>编程语言实现方式的特征<em>the
feature of a particular programming language
implementation</em></strong>，而不是编程语言自身的特征<em>the feature of
the programming language</em>。所以“编译性语言” <em>compile
language</em> 或者“解释性语言” <em>interpreter language</em>
的说法<strong>完全没有意义</strong>。完全可以给Lisp,Scheme系语言编写一个compiler(这些语言的解释器实现比较常见)，给C语言编写一个解释器也是完全可行的。</p>
<h2 id="racket基本语法以及parser实现">Racket基本语法以及parser实现</h2>
<p>建议先在<a
href="http://download.racket-lang.org/">Racket官网下载</a>原生Racket以及配套IDE
DrRacket，写Racket或者Scheme程序方便些。
另外本文interpreter实现基本不包含检测和错误处理，所以测试代码最好先在原生Racket里面执行下。</p>
<p>需要快速了解Racket基本语法，推荐此篇快速介绍文章<a
href="https://learnxinyminutes.com/docs/racket/">Learn X in Y minutes,
When x = Racket</a>。</p>
<h3 id="代数运算">代数运算</h3>
<!-- Jekyll, replace code block with caption to Jekyll highlight tag -->
<figure class="highlight code-block">
<figcaption>
<span class="language">lisp</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279">(</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #D7827E">2</span><span style="color: #575279"> (</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #D7827E">2</span><span style="color: #575279"> </span><span style="color: #D7827E">3</span><span style="color: #575279">))</span></span></code></pre>
</figure>
<p>先来个简单的Racket代码例子，上述代码较内层括号<code>(* 2 3)</code>是乘法运算，然后在外层括号内再将上述乘法运算结果加上2。
整个代码等价于数学或者常见编程语言<code>2 + 2 * 3</code>代码意义。</p>
<p>一开始就比较不同寻常，对于此类Racket代码可以看作<code>操作符 operator</code>以及<code>操作数 operand</code>的组合，再用括号包裹。比如<code>(+ 1 1)</code>就可以把<code>+</code>看作操作符。另外可以括号形式的代码嵌套，比如上述先乘后加的代数运算。</p>
<p>这种代码形式，实际非常简单，我们可以给一个更加明确的定义如下节。</p>
<h3 id="racket所有的东西都是">Racket所有的东西都是：</h3>
<p>就两种！</p>
<ol type="1">
<li>一个<code>atom</code>，比如数字<code>3</code>、字符串<code>"hello"</code>、<code>#t</code>、<code>#f</code>、<code>null</code>。也包括一种atom的：<code>识别符 identifier</code>,可以是<code>变量variable</code>,<br />
或者是<code>特别形式special form</code>诸如<code>define</code>、<code>lambda</code>、<code>if</code>。(涉及的名词或者术语，不理解没关系，再后文会一一介绍)</li>
<li>或者是在括号的一序列<em>sequence</em>东西<code>(t1 t2 t3 ... tn)</code>。</li>
</ol>
<p>该定义还有个专门的名称<a
href="https://en.wikipedia.org/wiki/S-expression">S-expression</a>，随着Lisp诞生给出的定义用来描述Lisp。</p>
<p>详说下第二种情况。括号里的第一东西t1，影响余下的序列中的东西。
如果是<code>special form</code>，比如<code>define</code>，以为定义一个东西，要么是变量<em>variable</em>，要么是函数<em>function</em>（<code>lambda</code>）。</p>
<p>如果不是<code>special form</code>，剩余情况一般是函数执行<em>function
call</em>，很多东西在Racket里都是函数，比如加减<code>+</code>和<code>-</code>。</p>
<p>在Racket里括号是很常见的，而且括号作用非常明确。不会遇到<code>f x y</code>是<code>(f x) y</code>还是<code>f (x y)</code>的疑惑。
Racket的括号直接影响着<code>解析parsing</code>，将代码转换成树形结构。实际上Racket代码本身就是树形结构。</p>
<p>如果没有了解过Lisp系语言，大部分人看到一段比较长的代码，都会觉得充满了括号的怪异语法。如果能抛开这些成见，学习使用后实际上能很快适应。</p>
<h3 id="token">Token</h3>
<p>具体到parser中第一步<code>生成token token generator</code>或者叫<code>词汇分析lexical Analysis</code>。可以参照上文实现语言通常流程小节引用的流程图，其中’parser’部分。</p>
<p>这个过程就是把代码字符串分割成多个有意义的符号。这个过程一般使用正则表达式<em>regural
expression</em>简称<em>regex</em>。这些符号专门的术语就是<code>token</code>。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> write token generator on ruby
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">class</span><span style="color: #575279"> </span><span style="color: #56949F">Racket</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">tokenize</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">str</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        str</span><span style="color: #797593">.</span><span style="color: #B4637A; font-style: italic">gsub</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;(&quot;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;( &quot;</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> add space after &#39;(&#39;</span></span>
<span class="line"><span style="color: #575279">           </span><span style="color: #797593">.</span><span style="color: #B4637A; font-style: italic">gsub</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;)&quot;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot; )&quot;</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> add space before &#39;)&#39;</span></span>
<span class="line"><span style="color: #575279">           </span><span style="color: #797593">.</span><span style="color: #575279">split</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot; &quot;</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> split string into an array(tokens) base on whitespaces</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>快速简介下ruby，本文在前言里面提及了面向新手，所以会对于不了解ruby的读者涉及一些介绍，<strong>这部分内容我会用引言块注明（如下），如果不需要，随意跳过。</strong>
不光会有ruby知识，还有一些别的编程知识。</p>
<blockquote>
<p>Ruby是一种<code>动态类型dynamic type</code>
<code>面向对象object oriented</code>编程语言。我定义了一个名叫Racket的<code>类class</code>。
其中定义了一个名叫tokenize的函数。函数有一个’str’的参数，用来接收代码字符串。注意class和method都使用了end明确表明各自代码块的结束部分，ruby里面大部分代码快都需要end结尾，比如if。<br />
另外ruby函数会自动返回最后一个对象。当然你也可以明确<em>explicitly</em>使用<code>return</code>，比如条件（if）分支需要返回的情形。</p>
</blockquote>
<p>代码很简单，先将这对括号”()“内测增加一个空格，方便最后<code>分割split</code>操作。<code>gsub</code>便是替换操作。</p>
<blockquote>
<p><code>str.gsub(...).gsub(...).split(...)</code>这种连着执行函数模式，术语叫做<em>chaining</em>。自己写的代码函数返回对象即可做到。<br />
另外这种风格并不是ruby或者别的某个语言特有的，是一种<code>习惯用法idiom</code>。好处就是少些变量名或者赋值，另外也没必要构造一个大而全方法，完全可以构建更合理多个方法并连续调用从而达到目标。</p>
</blockquote>
下面便测试下上述代码
使用系统的命令行工具到相应的代码目录。确保安装ruby后输入<code>irb</code>命令，定义一段代码string，传入<code>tokenize</code>函数生成token。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> Test Tokenize in irb
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">c</span><span style="color: #797593">:</span><span style="color: #575279">\</span><span style="color: #575279; font-style: italic">Projects</span><span style="color: #575279">\</span><span style="color: #575279; font-style: italic">RacketOnRuby</span><span style="color: #286983">&gt;</span><span style="color: #575279">irb</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">001</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #286983">&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">load</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;racket.rb&#39;</span></span>
<span class="line"><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">002</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #286983">&gt;</span><span style="color: #575279"> r </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #56949F">Racket</span><span style="color: #797593">.</span><span style="color: #286983">new</span></span>
<span class="line"><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic">&lt;Racket:0x00000002e67df8&gt;</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">003</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #286983">&gt;</span><span style="color: #575279"> str </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #EA9D34">%{(+ 1</span></span>
<span class="line"><span style="color: #EA9D34">irb(main)</span><span style="color: #797593">:</span><span style="color: #D7827E">004</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #EA9D34">&quot;      (* 2</span></span>
<span class="line"><span style="color: #EA9D34">irb(main):005:0&quot;</span><span style="color: #575279">         </span><span style="color: #797593">(</span><span style="color: #286983">-</span><span style="color: #575279"> </span><span style="color: #D7827E">7</span><span style="color: #575279"> </span><span style="color: #D7827E">3</span><span style="color: #797593">)))</span></span>
<span class="line"><span style="color: #575279">irb</span><span style="color: #797593">(</span><span style="color: #575279">main</span><span style="color: #797593">):</span><span style="color: #D7827E">006</span><span style="color: #797593">:</span><span style="color: #D7827E">0</span><span style="color: #EA9D34">&quot; }</span></span>
<span class="line"><span style="color: #EA9D34">=&gt; &quot;</span><span style="color: #797593">(</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #D7827E">1</span><span style="color: #575279">\n     </span><span style="color: #797593">(</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #D7827E">2</span><span style="color: #575279">\n        </span><span style="color: #797593">(</span><span style="color: #286983">-</span><span style="color: #575279"> </span><span style="color: #D7827E">7</span><span style="color: #575279"> </span><span style="color: #D7827E">3</span><span style="color: #797593">)))</span><span style="color: #575279">\n</span><span style="color: #EA9D34">&quot;</span></span>
<span class="line"><span style="color: #EA9D34">irb(main):007:0&gt; p r.tokenize(str)</span></span>
<span class="line"><span style="color: #EA9D34">[&quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">+</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">1</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">*</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">2</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">-</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">7</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">3</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;]</span></span>
<span class="line"><span style="color: #EA9D34">=&gt; [&quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">+</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">1</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">*</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">2</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #286983">-</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">7</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #D7827E">3</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;, &quot;</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;]</span></span></code></pre>
</figure>
<blockquote>
<ul>
<li>第1行（最左边的行号）<code>irb</code>进入ruby
REPL。没听过REPL，先粗略认为REPL就是专门执行代码的命令工具。下文<a
href="#工具repl-read-eval-print-loop">REPL章节</a>会详细的涉及，因为我们实现Racket也要写个Racket的REPL，来方便测试。</li>
<li>第2行加载包含Racket class的相应的ruby file。
我的ruby文件名就叫做racket.rb。</li>
<li>第4行创建一个Racket的对象<code>实例instance</code>。该实例将来调用相应的函数进行<code>tokenize</code>以及后续的操作。Ruby的语法syntax，很多时候执行函数都可以省略括号，比如此处创建对象的时候调用<code>new</code>构造函数，可选写法：<code>Racket.new()</code>两种代码等价的。</li>
<li>6行到9行，定义了变量名为<code>str</code>的code string。
<code>%{...}</code>是ruby定义多行字符串的一种语法syntax。</li>
<li>第10行，irb会自动输出之前代码执行结果返回的对象（包括之前的3、5行）。其中把换行转义成了’’输出在一行。</li>
<li>第11行，调用<code>tokenize</code>函数，并传入上一步定义的string。并打印输出结果即tokens</li>
</ul>
</blockquote>
<blockquote>
<p>可以把上述命令行中的ruby测试代码放入专门的rb文件，这样就无需在每次重新测试再敲代码。例如github项目中的<em>example.rb</em>，直接系统命令行执行<code>ruby example.rb</code></p>
</blockquote>
<p>此前代码，在<code>tokenize</code>函数多了第一步处理是把多个空白符转化成单个隔空”
“，然而写这篇文章的时候，我重新审查了下代码，并不需要多此一举。多余的代码：<code>str.gsub(/\s{2,}/, " ")</code></p>
<p>原因是<code>split</code>方法传入单个空格字符串的时候，会基于空白符<em>whitespace</em>分割，而且会忽略余下的紧挨着的空白符。<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a></p>
<p>token生成好了，下面便是分析token并生成AST了。</p>
<h2 id="abstract-syntax-tree-parse-tree">Abstract Syntax Tree (Parse
Tree)</h2>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">generate_ast</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">tokens</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">aux</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">tokens</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">acc</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> tokens</span><span style="color: #797593">.</span><span style="color: #575279">empty?</span></span>
<span class="line"><span style="color: #797593">            </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> no tokens left, return result</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> acc</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        token </span><span style="color: #286983">=</span><span style="color: #575279"> tokens</span><span style="color: #797593">.</span><span style="color: #575279">shift </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> get first token</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;(&#39;</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> token </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> start one s-expression</span></span>
<span class="line"><span style="color: #575279">            sub_ast </span><span style="color: #286983">=</span><span style="color: #575279"> aux tokens</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">[]</span></span>
<span class="line"><span style="color: #575279">            acc</span><span style="color: #797593">.</span><span style="color: #575279">push sub_ast</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">            aux</span><span style="color: #797593">(</span><span style="color: #575279">tokens</span><span style="color: #797593">,</span><span style="color: #575279">  acc</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> recursive call to continue handling rest tokens</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">elsif</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;)&#39;</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> token </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> end one s-expression</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> acc</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">            acc</span><span style="color: #797593">.</span><span style="color: #575279">push atom</span><span style="color: #797593">(</span><span style="color: #575279">token</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> convent current token to atom</span></span>
<span class="line"><span style="color: #575279">            aux tokens</span><span style="color: #797593">,</span><span style="color: #575279"> acc </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> recursive</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">    aux tokens</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">[]</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> initial call helper</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>真正起作用的是<code>generate_ast</code>内部定义<code>aux</code>（<em>auxiliary辅助</em>,
<em>helper</em>）的方法，处理tokens，其参数<code>acc</code>（<em>accumulator累加器</em>）存放的处理得到的AST。</p>
<p>主要使用<code>递归 recursion</code>从左到右处理<code>tokens</code>里面的每一个token：</p>
<ul>
<li>tokens为空的时候，返回<code>acc</code>即AST结果。</li>
<li>当遇到左括号时，说明遇到一个s-expression的序列，递归调用<code>aux</code>方法的时候给<code>acc</code>参数传入一个新的空array（上述第10行代码），用来存储这部分subdivision
s-expression序列对应的AST结果。<br />
第11行，递归调用处理完返回<code>subdivision acc</code>结果，追加到原来acc后面。</li>
<li>当遇到右括号的时候，说明s-expression的结束，返回结果<code>acc</code>，对应上一点的<code>subdivsion acc</code>。<br />
</li>
<li>剩余其他情况，将token转化为atom，紧接的下文涉及atom实现细节。</li>
</ul>
<p>实际<code>generate_ast</code>方法简化下就是匹配括号的代码，包括嵌套<em>nested</em>结构。</p>
<blockquote>
<p>上述代码并没有检测括号是否匹配，因为需要文章简洁，这里只贴出不检测括号的代码，github上面的源文件里面包含有完整的括号检测。<br />
racket里面除了可以使用圆括号()，也可以使用方括号[]，两者功能作用没有区别，编码习惯在某些地方会使用[]，但不遵循也不会有什么实质影响。唯一注意的就是要对应的括号匹配，不能混用，比如<code>(+ 1 1]</code>就是语法不正确。</p>
</blockquote>
<h3 id="atom">Atom</h3>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> s-expression atom
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">atom</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">token</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    str_part </span><span style="color: #286983">=</span><span style="color: #575279"> token</span><span style="color: #797593">[</span><span style="color: #EA9D34">/^&quot;</span><span style="color: #797593">(</span><span style="color: #EA9D34">.*</span><span style="color: #797593">)</span><span style="color: #EA9D34">&quot;$/</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> try match string(start and end with &quot;)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #286983">not</span><span style="color: #575279"> str_part</span><span style="color: #797593">.</span><span style="color: #575279">nil?</span></span>
<span class="line"><span style="color: #575279">        str_part</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> token</span><span style="color: #797593">[</span><span style="color: #EA9D34">/</span><span style="color: #797593">(</span><span style="color: #EA9D34">?=</span><span style="color: #797593">(</span><span style="color: #286983">\.</span><span style="color: #EA9D34">|</span><span style="color: #797593">[</span><span style="color: #286983">eE</span><span style="color: #797593">]))(</span><span style="color: #286983">\.\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?</span><span style="color: #797593">([</span><span style="color: #286983">eE</span><span style="color: #797593">][</span><span style="color: #286983">+-</span><span style="color: #797593">]</span><span style="color: #EA9D34">?</span><span style="color: #286983">\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?$/</span><span style="color: #797593">]</span><span style="color: #575279">  </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> decimal</span></span>
<span class="line"><span style="color: #575279">        token</span><span style="color: #797593">.</span><span style="color: #575279">to_f</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> token</span><span style="color: #797593">[</span><span style="color: #EA9D34">/^</span><span style="color: #286983">\d</span><span style="color: #EA9D34">+$/</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> integer</span></span>
<span class="line"><span style="color: #575279">        token</span><span style="color: #797593">.</span><span style="color: #575279">to_i</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> symbol</span></span>
<span class="line"><span style="color: #575279">        token</span><span style="color: #797593">.</span><span style="color: #575279">to_sym</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>刚才上文我们已经处理了s-expression序列，即<a
href="#racket所有的东西都是">上文提及s-expression</a>第二种情形。此处<code>atom</code>为第一种情况，具体又有细分，可能是string、数字、也有可能是<code>identifier</code>。对应代码中<code>if</code>语句各个分支，通过正则式尝试匹配<code>token</code>（Ruby
string对象）：</p>
<ol type="1">
<li><p>在Racket中头尾各一个双引号<code>"</code>来包含字符串。第一个if便是通过正则式匹配首尾”，如果的确是string，其中间部分取出就是对应的Ruby
string类型的对象。</p></li>
<li><p>第二个if分支判断是否为浮点数。这里的正则式看起来很复杂，简单代替方案是仅仅匹配小数点（正则式为
<code>/\.\d+$/</code>）。这里复杂的正则式是除了用来匹配小数外，还能匹配指数<em>exponential</em>，Ruby中指数类似1e5也算作浮点数(等同于10000.0，Racket中也是同样的)。to_f便是将string转化为float浮点数的方法。这里举出4个数<code>.003</code>
<code>0.5</code> <code>32e3</code>
<code>.24e5</code>，这些都是浮点数，我们的正则式便是能够匹配出对应小数点部分以及指数部分，测试代码如下，第一行这四个数尝试使用该正则式匹配，第二行是匹配部分的结果:</p>
<figure class="highlight code-block">
<figcaption>
<p><span class="language">ruby</span> decimal and exponential</p>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279">    </span><span style="color: #797593">[</span><span style="color: #EA9D34">&#39;.003&#39;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;0.5&#39;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;32e3&#39;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #EA9D34">&#39;.24e5&#39;</span><span style="color: #797593">].</span><span style="color: #575279">map</span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">num</span><span style="color: #797593">|</span><span style="color: #575279"> num</span><span style="color: #797593">[</span><span style="color: #EA9D34">/</span><span style="color: #797593">(</span><span style="color: #EA9D34">?=</span><span style="color: #797593">(</span><span style="color: #286983">\.</span><span style="color: #EA9D34">|</span><span style="color: #797593">[</span><span style="color: #286983">eE</span><span style="color: #797593">]))(</span><span style="color: #286983">\.\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?</span><span style="color: #797593">([</span><span style="color: #286983">eE</span><span style="color: #797593">][</span><span style="color: #286983">+-</span><span style="color: #797593">]</span><span style="color: #EA9D34">?</span><span style="color: #286983">\d</span><span style="color: #EA9D34">+</span><span style="color: #797593">)</span><span style="color: #EA9D34">?$/</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> =&gt; [&quot;.003&quot;, &quot;.5&quot;, &quot;e3&quot;, &quot;.24e5&quot;]</span></span></code></pre>
</figure>
<blockquote>
<p>Ruby Array的map方法，是将其中每个元素都进行block中处理。
<code>{ |num| ...}</code>形式就是block，此处Array.map会往block的num参数
传入单个元素。</p>
</blockquote></li>
<li><p>第三个if分支，尝试匹配是否为整数。to_i便把string是转化整数<em>integer</em>的方法</p></li>
<li><p>最后一个else分支，剩下情况可能是变量名或者special
form比如<code>lambda</code> <code>define</code>等。最后转化为Ruby
<code>符号Symbol</code>类型。所谓symbol类似string，symbol为不可变<code>immutable</code>，而且其值一样的话，就是同一个对象。</p>
<blockquote>
<p>Ruby中symbol是以<code>:</code>作为开头，例如<code>:hello</code>。两两比对的时候symbol效率更高。不像string一个一个字符<em>char</em>进行比对，symbol直接比对两者在内存中是否为同一个对象。</p>
</blockquote></li>
</ol>
<p>到此为止，实现了生成AST的部分，下面就要涉及interpreter部分了。</p>
<h2
id="eval方法实现executorinterpreter">eval方法实现executor(interpreter)</h2>
<p>有些表达式<em>expression</em>中会包含变量<em>variable</em>，求值<em>evaluate</em>这些表达式就需要<code>environment</code>，通过variable获得对应值<em>vaLue</em>。</p>
<p>environment的实现是<code>metalanguage</code>的一部分，metalanguage这里就是我们使用的Ruby。这里使用hash数据结构来代表environment。</p>
<h3 id="完成代数运算eval">完成代数运算eval</h3>
文章一开始的提及的代数运算的Racket代码<code>(+ 1 (* 2 3))</code>，首先将其实现:
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> eval algebra operators
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">()</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">{</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593">:</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">y</span><span style="color: #797593">|</span><span style="color: #575279"> x</span><span style="color: #286983">+</span><span style="color: #575279">y</span><span style="color: #797593">},</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593">:</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">y</span><span style="color: #797593">|</span><span style="color: #575279"> x</span><span style="color: #286983">*</span><span style="color: #575279">y</span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Numeric</span></span>
<span class="line"><span style="color: #575279">        exp </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> is a number(integer and float) return itself</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">+</span><span style="color: #575279"> </span><span style="color: #286983">or</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">*</span></span>
<span class="line"><span style="color: #575279">        env</span><span style="color: #797593">[</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">].</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">),</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">2</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">        results </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">subexp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">subexp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">        results</span><span style="color: #797593">[</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>增加了两个方法<code>initialize</code>以及<code>eval</code>。</p>
<blockquote>
<p><code>initialize</code>方法是Ruby的对象的构造器方法，即<code>new</code>对象时候会调用该方法，该方法可以省略，我们之前<code>parser</code>部分就不需要构造方法，所以就一直没有<code>initialize</code>。</p>
</blockquote>
<blockquote>
<p>Ruby中<code>@</code>开头的变量是<code>实例变量instance variable</code>，作用范围为单个对象实例内，所有该对象的内部方法都可以访问到。<br />
另外<code>@@</code>两个at符号开头是<code>类变量class variable</code>，顾名思义即同一个类创建的所有对象实例
都共享同一个类变量。<br />
Ruby<strong>不需要提前声明variable</strong>，赋值一个之前不存在的variable，会自动创建该variable。</p>
</blockquote>
<p>其中<code>initialize</code>方法中，定义了一个<code>@env</code>实例变量，并赋值了一个hash。之前说过，在Racket中代数运算看作函数，metalanguage(Ruby)实现了<code>+</code>和<code>*</code>各自对应的lambda（或者叫Proc
object，ruby的术语），lambda可以看作匿名函数，该匿名函数接受两个参数<code>x``y</code>，将其相加或者相乘。</p>
<p>后文还会详细介绍lambda，因为我们也要实现Racket的lambda，Racket和Ruby的lambda基本是同一个东西，仅语法有区别。</p>
<p>eval方法依旧含有recursive call，递归很适合处理嵌套形式，处理
子表达式<em>subexpression</em>，需要返回的情形结果可能有差异。</p>
<ul>
<li>第一个if条件分支，判断如果表达式只是纯粹数字，那么不需要额外处理，返回自身。</li>
<li>第二个条件分支，涉及expression的首个thing如果是<code>:+</code>或者<code>:*</code>，<code>env[ exp[0] ]</code>则去environment中查找对应的函数。调用传入expression紧接着的2个thing，作为两个操作数。注意此处都会先执行下eval方法，因为可能是需要处理的subexpression，同时也是使用的同样的environment。</li>
<li>最后一个条件分支，之前实现的parser实际上可以处理多个expression，例如<code>(+ 1 1) (* 2 2) (+ 3 4)</code>这样的代码中包含三个expression，parser处理完后的AST为<code>[[:+, 1, 1], [:*, 2, 2], [:+, 3, 4]]</code>，包含三个expression处理后的AST的array。即使只有一个expression，parser处理后也是一个长度为1的array，例如该章开始提到的代码，parse后的结果：<code>[ [:+ 1 [:* 2 3]] ]</code>。<br />
这里，我返回的最后一个结果。当然也可以直接放回<code>results</code>结果array。自己写的interpreter，细节由自己定义。</li>
</ul>
<h3 id="function-call以及variables-in-environment">Function
call以及Variables in environment</h3>
上面处理加和乘，可以改写成处理任何方法的通用办法.
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> updated call functions
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval_expressions</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exps</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    results </span><span style="color: #286983">=</span><span style="color: #575279"> exps</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">one_exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">one_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    results</span><span style="color: #797593">[</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span></span>
<span class="line"><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">lookup_env</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">var</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        error_no_var </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;undefined: </span><span style="color: #286983">\&quot;</span><span style="color: #EA9D34">%s</span><span style="color: #286983">\&quot;</span><span style="color: #EA9D34">&quot;</span><span style="color: #575279"> </span><span style="color: #286983">%</span><span style="color: #575279"> var</span></span>
<span class="line"><span style="color: #575279">        val </span><span style="color: #286983">=</span><span style="color: #575279"> env</span><span style="color: #797593">[</span><span style="color: #575279">var</span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> val</span><span style="color: #797593">.</span><span style="color: #575279">nil?</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">raise</span><span style="color: #575279"> error_no_var</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> val</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Numeric</span></span>
<span class="line"><span style="color: #575279">        exp </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> is a number(integer and float) return itself</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Symbol</span></span>
<span class="line"><span style="color: #575279">        lookup_env</span><span style="color: #797593">(</span><span style="color: #575279">env</span><span style="color: #797593">,</span><span style="color: #575279"> exp</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">        operator </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> first thing of s-expression sequence.</span></span>
<span class="line"><span style="color: #575279">        operands </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">].</span><span style="color: #575279">map </span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">sub_exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">sub_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> the rest things of sequence</span></span>
<span class="line"><span style="color: #575279">        operator</span><span style="color: #797593">.</span><span style="color: #575279">call </span><span style="color: #286983">*</span><span style="color: #575279">operands</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>将处理多个expression的办法提炼成<code>eval_expressions</code>方法。这样的话parse处理完后的AST(结果都是array，一个或多个expression)就先调用<code>eval_expressions</code>处理。而<code>eval</code>只用来处理单个expression。这样处理的理由，如果包含在<code>eval</code>一个条件分支的话，会与单个expression处理混乱（因为同样使用array来存放s-expression）。</p>
<p><code>else</code>分支就是处理方法调用，expression第一个thing也执行了<code>eval</code>。这样就可以处理这样的<code>( (if #t + *) 2 3 )</code>Racket代码（第一个thing也可能是sub
expresion）。</p>
<blockquote>
<p><code>operator.call *operands</code>中<code>oprands</code>是array，其前面<code>*</code>是<code>splat operator</code>。作用是将数组拆开，每个元素对应到单个参数。反过来，在函数参数声明时候也可以使用<code>*</code>，作用也是相反的，将传入的单个参数值组成array。</p>
</blockquote>
<p>另外，多了处理symbol
atom的步骤，一般symbol为variable的时候，就需要到environment查找对应的value，即<code>lookup_env</code>方法。该方法很简单，就是通过variable作为key查找environment对应的值，没有variable的话就抛出一个简单错误提示该variable没被定义。</p>
如果完整代数运算，除法和减法<code>:/</code>，<code>:-</code>可以类似上面写法。但是重复劳动了，用程序来做重复的事。另外还有一点需要改进，Racket中代数运算符，可以接受多个数字，进行累积运算。<br />
例如<code>(+ 1 4 5 7)</code>执行结果为<code>17</code>，<code>(* 2 3 4)</code>执行结果为<code>24</code>。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> updated algebra
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279; font-style: italic">ALGEBRA_OPERATORS</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[:</span><span style="color: #286983">+</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">-</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">*</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">/</span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">()</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">{</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #56949F">ALGEBRA_OPERATORS</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">opt</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">[</span><span style="color: #575279">opt</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #286983">*</span><span style="color: #575279; font-style: italic">operands</span><span style="color: #797593">|</span><span style="color: #575279"> operands</span><span style="color: #797593">.</span><span style="color: #575279">inject</span><span style="color: #797593">(</span><span style="color: #575279">opt</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>改写成上述代码，通过程序往environment增加每个代数运算符对应的lambda函数。看到这似乎炫技嫌疑，但实际后面也有相同的思想的实现，比较大小的comparison
operator也是类似的（也是能接受多个参数）</p>
<p>至此<code>eval</code>的大致结构功能如此。后文涉及的新的Racket
feature，就是往<code>eval</code>增加更多情况的处理，方式可能是增加条件分支，也有可能是往environment中增加函数（可以看作Racket自带的函数）。</p>
<h3 id="工具repl-read-eval-print-loop">工具REPL,
Read-Eval-Print-Loop</h3>
在继续完备eval方法之前，首先实现REPL这个工具，让调试Racket代码更加方便。就如之前执行Ruby代码的<code>irb</code>。
REPL全称read-eval-print-loop顾名思义，其过程: 读取code -&gt;
eval求值这段代码 -&gt; 输出结果 -&gt; 循环上述步骤。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> REPL
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">repl</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">prompt</span><span style="color: #286983">=</span><span style="color: #EA9D34">&#39;RacketOnRb &gt;&gt;&#39;</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">output_prompt</span><span style="color: #286983">=</span><span style="color: #EA9D34">&quot;=&gt;&quot;</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">while</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #B4637A; font-style: italic">print</span><span style="color: #575279"> prompt</span></span>
<span class="line"><span style="color: #575279">        code </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">gets</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">begin</span></span>
<span class="line"><span style="color: #575279">            ast </span><span style="color: #286983">=</span><span style="color: #575279"> parse</span><span style="color: #797593">(</span><span style="color: #575279">code</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">            result </span><span style="color: #286983">=</span><span style="color: #575279"> eval_expressions</span><span style="color: #797593">(</span><span style="color: #575279">ast</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #B4637A; font-style: italic">puts</span><span style="color: #575279"> output_prompt </span><span style="color: #286983">+</span><span style="color: #575279"> result</span><span style="color: #797593">.</span><span style="color: #575279">to_s</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">rescue</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">Exception</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> e</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #B4637A; font-style: italic">puts</span><span style="color: #575279"> e</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>相当直接的代码，一个无限循环，接受console输入Racket代码，然后解析执行代码，即之前描述的过程。<br />
执行<code>parse</code>，<code>eval</code>这部分时，会尝试捕获异常，如果有异常只是打印出来，继续loop。这样就能避免出错整个program终止，需要重新执行该repl方法。</p>
<h3 id="定义变量variable">定义变量variable</h3>
前面已经完成查询variable对应的value的方法。相应我们需要实现定义变量，其语法<code>(define &lt;var&gt; &lt;exp&gt;)</code>。
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">define</span></span>
<span class="line"><span style="color: #575279">    _</span><span style="color: #797593">,</span><span style="color: #575279"> var</span><span style="color: #797593">,</span><span style="color: #575279"> value_exp </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"><span style="color: #575279">    env</span><span style="color: #797593">[</span><span style="color: #575279">var</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> value_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env </span><span style="color: #797593">)</span></span></code></pre>
</figure>
<p>放置于处理function call分支之前即可。</p>
<h3 id="条件判断if语句">条件判断、if语句</h3>
<p>Racket中用<code>#t</code>和<code>#f</code>表示true和false。</p>
Racket
if的语法：<code>(if &lt;test-exp&gt; &lt;then-exp&gt; &lt;else-exp&gt;)</code>当<test-exp>执行结果不是<code>#f</code>的时候，执行<code>&lt;then-exp&gt;</code>分支，否则执行<code>&lt;else-exp&gt;</code>分支
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">{</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">:&#39;</span><span style="color: #286983">#t</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span><span style="color: #797593">,</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">:&#39;</span><span style="color: #286983">#f</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span></span>
<span class="line"><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ...</span></span>
<span class="line"><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">if</span></span>
<span class="line"><span style="color: #575279">    _</span><span style="color: #797593">,</span><span style="color: #575279"> test_exp</span><span style="color: #797593">,</span><span style="color: #575279"> then_exp</span><span style="color: #797593">,</span><span style="color: #575279"> else_exp </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">test_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> else_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env </span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> other than false(#f)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> then_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>ruby注释使用<code>#</code>，如果symbol含有#的话，需要用引号括起来。这里会把Racket的<code>#t #f</code>转化为Ruby中的true和false。</p>
<h3 id="比较操作comparison-operators">比较操作comparison operators</h3>
至于比较操作，上文提过了类似代数操作实现。
当有多个需要比较的对象时，比较操作需要两两比较，所有两两比较结果为true，则返回true，否则false。
<code>each_cons(n)</code>就是(Ruby提供方法来遍历连续<em>consecutive</em>的n个元素)。<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> comparision
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279; font-style: italic">COMPARISION</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[:</span><span style="color: #286983">==</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">!=</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&lt;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&gt;</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&lt;=</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">&gt;=</span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">()</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ...</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #56949F">COMPARISION</span><span style="color: #797593">.</span><span style="color: #575279">map </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">opt</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">[</span><span style="color: #575279">opt</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #286983">*</span><span style="color: #575279; font-style: italic">args</span><span style="color: #797593">|</span><span style="color: #575279"> args</span><span style="color: #797593">.</span><span style="color: #575279">each_cons</span><span style="color: #797593">(</span><span style="color: #D7827E">2</span><span style="color: #797593">).</span><span style="color: #575279">all? </span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">y</span><span style="color: #797593">|</span><span style="color: #575279"> x</span><span style="color: #797593">.</span><span style="color: #575279">method</span><span style="color: #797593">(</span><span style="color: #575279">opt</span><span style="color: #797593">).</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279">y</span><span style="color: #797593">)}</span><span style="color: #575279"> </span><span style="color: #797593">}</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>Ruby和其他大部分语言，使用<code>=</code>代表赋值操作，所以比较是否相等时候使用<code>==</code>。但是Racket有专门的<code>define</code>操作，所以依旧使用<code>=</code>代表比较是否相等的函数。<br />
我追求简单，所以实现套用Ruby语法。如果要改为Scheme
Racket语法也很简单，多做一次符号映射即可，其他不做赘述了。</p>
<h3 id="cons-cell-and-list">Cons Cell and List</h3>
<p><code>cons</code>操作用来构建一个pair，其通过<code>car</code>获得pair的第一个数据，通过<code>cdr</code>获得pair的第二个数据，pair有专门的术语：<code>cons cell</code>。</p>
<p>另外Racket有个特许且常用的<code>cons cell</code>形式：<code>list</code>，例如<code>(cons 1 (cons 2 (cons 3 (cons 4 null))))</code>代码，nested
cons
cells，最后一个（最内部的pair）的第二数据以<code>null</code>为结尾。<br />
<code>null</code>在Racket中代表空list，<code>null?</code>判断是否为空的函数。list有个更加简便的写法<code>(list 1 2 3 4)</code>等同上行的代码例子。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 40%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Primitive</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">null</td>
<td style="text-align: left;">The empty list</td>
<td style="text-align: left;">null</td>
</tr>
<tr class="even">
<td style="text-align: left;">cons</td>
<td style="text-align: left;">Construct a list</td>
<td style="text-align: left;">(cons 2 (cons 3 null))</td>
</tr>
<tr class="odd">
<td style="text-align: left;">car</td>
<td style="text-align: left;">Get rst element of a list</td>
<td style="text-align: left;">(car some-list)</td>
</tr>
<tr class="even">
<td style="text-align: left;">cdr</td>
<td style="text-align: left;">Get tail of a list</td>
<td style="text-align: left;">(cdr some-list)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">null?</td>
<td style="text-align: left;">Return #t for the empty-list and #f
otherwise</td>
<td style="text-align: left;">(null? some-value)</td>
</tr>
</tbody>
</table>
<p>对于Ruby实现代码，我们使用array来存放<code>cons cells</code>，固定两个元素。</p>
<p>对于<code>list</code>函数实现，依旧采用recursion方式，cons（直接构造Ruby
array）第一个参数以及余下参数构成的list，很直白实现方式。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> cons cells
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #797593">:</span><span style="color: #286983">null?</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">null</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> exp </span><span style="color: #797593">},</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> racket empty list.</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">cons</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">x</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">cell</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #797593">[</span><span style="color: #575279">x</span><span style="color: #797593">,</span><span style="color: #575279"> cell</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">},</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">car</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">cell</span><span style="color: #797593">|</span><span style="color: #575279"> cell</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]},</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">cdr</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">cell</span><span style="color: #797593">|</span><span style="color: #575279"> cell</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #797593">},</span></span>
<span class="line"><span style="color: #797593">:</span><span style="color: #286983">list</span><span style="color: #575279"> </span><span style="color: #797593">=&gt;</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #286983">*</span><span style="color: #575279; font-style: italic">args</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> racket code &#39;(list 1 2 3)&#39; is equivalent to &#39;(cons 1 (cons 2 (cons 3 null)))&#39;</span></span>
<span class="line"><span style="color: #575279">    racket_list_helper</span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #286983">do</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">args</span><span style="color: #797593">|</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> args</span><span style="color: #797593">.</span><span style="color: #575279">empty? </span><span style="color: #286983">then</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">null</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593">[</span><span style="color: #575279">args</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">],</span><span style="color: #575279"> racket_list_helper</span><span style="color: #797593">.</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279">args</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">])]</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    racket_list_helper</span><span style="color: #797593">.</span><span style="color: #575279">call</span><span style="color: #797593">(</span><span style="color: #575279">args</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #286983">end</span></span></code></pre>
</figure>
<!-- TODO: map, filter, fold -->
<h3 id="functionslambda-and-apply">Functions，Lambda and Apply</h3>
<!-- pullquote "has-quotes"  endpullquote  TODO: pullquote style  -->
<blockquote>
<p>问题弄清楚后，答案自然就清楚了。</p>
</blockquote>
<p>到了我觉得最重要的function部分了。目标实现function，只需要搞清楚何为function就知道如何实现，首先先要明确一些相关的概念。</p>
<p>Racket的函数遵循<code>lexical scope</code>又称作<code>static scope</code>，函数的正文部分求值时，所用的environment在该函数被定义时候的enviroment。相对立的<code>dynamic scope</code>，就是函数求值时，使用的函数被调用的enviroment。</p>
<blockquote>
<p>The body of function is evaluated in the environment when the
function is <strong>defined</strong>, not the environment when the
function is <strong>called</strong>.</p>
</blockquote>
<p>现在主流编程语言基本都是使用<code>lexical scope</code>，程序行为更可控。</p>
<p>除了定义的时候的environment，方法执行的时候，还会将该environment扩展添加参数<em>parameters</em>以及其对应传入的值<em>arguments</em>。</p>
<p>function(或者叫lambda,
procedure)的实现代码如下，存放lambda的parameters和body，以及定义时候的envrioment，就如同上文描述那样。</p>
<p>定义了Closure
class，只是用来存放closure的值。也可以用数组<code>[:closure, parameters, body, env]</code>存放，通过index取值，但是这样的话<code>:closure</code>可以被覆盖。</p>
<p>真正执行部分，处于之前执行方法部分，之前处理例如加法之类的primitive
procedures。现在增加分支专门处理，用户定义的函数<em>compound
procedures</em>。
操作数部分与之前一样，先eval，然后补充进函数定义时的environment。该environment为执行函数体<em>body</em>的环境，然后求值。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> closure
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #286983">class</span><span style="color: #575279"> </span><span style="color: #56949F">Closure</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">attr_reader</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">parameters</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">body</span><span style="color: #797593">,</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">env</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">initialize</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">parameters</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">body</span><span style="color: #575279"> ,</span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">parameters</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> parameters</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">body</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> body</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> env</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other part code</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">lambda</span></span>
<span class="line"><span style="color: #575279">        _</span><span style="color: #797593">,</span><span style="color: #575279"> parameter_names</span><span style="color: #797593">,</span><span style="color: #575279"> fun_body </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #56949F">Closure</span><span style="color: #797593">.</span><span style="color: #286983">new</span><span style="color: #797593">(</span><span style="color: #575279">parameter_names</span><span style="color: #797593">,</span><span style="color: #575279"> fun_body</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other part code</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> call function</span></span>
<span class="line"><span style="color: #575279">        operator </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">],</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> first thing of s-expression sequence.</span></span>
<span class="line"><span style="color: #575279">        operands </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">].</span><span style="color: #575279">map </span><span style="color: #797593">{|</span><span style="color: #575279; font-style: italic">sub_exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">sub_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #797593">}</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> the rest things of sequence</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">is_a? </span><span style="color: #575279; font-style: italic">Closure</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> compounded procedures(user-defined)# extends environment with parameters and their actual arguments applied.</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">            env_fn </span><span style="color: #286983">=</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">parameters</span><span style="color: #797593">.</span><span style="color: #575279">zip</span><span style="color: #797593">(</span><span style="color: #575279">operands</span><span style="color: #797593">)</span><span style="color: #575279"> </span><span style="color: #286983">+</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">env</span></span>
<span class="line"><span style="color: #575279">            body </span><span style="color: #286983">=</span><span style="color: #575279"> operator</span><span style="color: #797593">.</span><span style="color: #575279">body</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279">body</span><span style="color: #797593">,</span><span style="color: #575279"> env_fn</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> primitive operators</span></span>
<span class="line"><span style="color: #575279">            operator</span><span style="color: #797593">.</span><span style="color: #575279">call </span><span style="color: #286983">*</span><span style="color: #575279">operands</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span></code></pre>
</figure>
<p>另外environment有了较大的改动，之前使用hash结构，在写这篇文章的时候，我重新审查代码时候，发现有较大缺陷：</p>
<ul>
<li>之前hash结构，define定义新变量是直接更改该hash本身，mutation操作。定义lambda的时候，最初直接传入env本身，然而因为hash是可变的，所以实现的是<code>dynamic scope</code>方式，后续对env操作也会影响函数定义是当前的env(就是同一个对象)。</li>
<li>我最初的处理方法是，对于函数定义时候的env，使用一个新的对象<code>env.clone</code>。似乎解决了问题，但是在某些simultaneous同时发生，比如需要两个方法同时定义，如果通过<code>env.clone</code>，两个方法的env是两个独立对象，然而我们需要两个方法env都是同一个对象，因为它们处于并列状态，例如<code>letrec</code>（不是本文重点，但代码中有实现）。</li>
</ul>
<p>所以，需要改变的是：</p>
<ul>
<li>define添加新的variable到当前env（并不改变原先env）作为新的env。相当于新的environment是immutable。</li>
<li>定义lambda的时候，直接使用当前的env。</li>
</ul>
<figure>
<img src="/images/2017-RacketOnRuby/closure-env.jpg"
alt="the environment of the closure" />
<figcaption aria-hidden="true">the environment of the
closure</figcaption>
</figure>
<p>对应到ruby代码实现。使用array取代hash，其中每个元素即变量和其对应的值（2个元素的array分别存variable,value）。
define时候通过 <code>env[0..-1]</code>
重新赋值env。由于现在需要直接更改当前的environment，而且ruby不支持参数传入引用，所以我使用<code>env[0..-1] = [new array]</code>将env内的array中的元素替换成新的env（包含新定义的variable），来达到更改当前environment目的。</p>
<figure class="highlight code-block">
<figcaption>
<span class="language">ruby</span> new environment
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">[:&#39;</span><span style="color: #286983">#t</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">,</span><span style="color: #575279">  </span><span style="color: #D7827E">true</span><span style="color: #797593">],</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">[:&#39;</span><span style="color: #286983">#f</span><span style="color: #797593">&#39;</span><span style="color: #575279"> </span><span style="color: #797593">,</span><span style="color: #575279">  </span><span style="color: #D7827E">false</span><span style="color: #797593">],</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> Racket &#39;not&#39; operator if exp is #f, results #t. otherwise false. it differents from ruby not</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">[:</span><span style="color: #286983">not</span><span style="color: #575279"> </span><span style="color: #797593">,</span><span style="color: #575279">  </span><span style="color: #B4637A; font-style: italic">lambda</span><span style="color: #575279"> </span><span style="color: #797593">{</span><span style="color: #575279"> </span><span style="color: #797593">|</span><span style="color: #575279; font-style: italic">exp</span><span style="color: #797593">|</span><span style="color: #575279"> </span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span><span style="color: #286983">==</span><span style="color: #575279">exp </span><span style="color: #286983">then</span><span style="color: #575279"> </span><span style="color: #D7827E">true</span><span style="color: #575279"> </span><span style="color: #286983">else</span><span style="color: #575279"> </span><span style="color: #D7827E">false</span><span style="color: #575279"> </span><span style="color: #286983">end</span><span style="color: #575279"> </span><span style="color: #797593">}],</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other primitive procedures.</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #797593">]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">eval</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">exp</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #286983">=</span><span style="color: #797593; font-style: italic">@</span><span style="color: #575279; font-style: italic">env</span><span style="color: #797593">)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">def</span><span style="color: #575279"> </span><span style="color: #D7827E">lookup_env</span><span style="color: #797593">(</span><span style="color: #907AA9; font-style: italic">env</span><span style="color: #575279">, </span><span style="color: #907AA9; font-style: italic">var</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        error_no_var </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;undefined: %s !&quot;</span><span style="color: #575279"> </span><span style="color: #286983">%</span><span style="color: #575279"> var</span></span>
<span class="line"><span style="color: #575279">        var_val </span><span style="color: #286983">=</span><span style="color: #575279"> env</span><span style="color: #797593">.</span><span style="color: #575279">assoc var</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">if</span><span style="color: #575279"> var_val</span><span style="color: #797593">.</span><span style="color: #575279">nil?</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">raise</span><span style="color: #575279"> error_no_var</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">elsif</span><span style="color: #575279"> var_val</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #575279; font-style: italic">UNASSIGNED_VAL</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">raise</span><span style="color: #575279"> </span><span style="color: #EA9D34">&quot;the unassigned value should not be access.&quot;</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">else</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #286983">return</span><span style="color: #575279"> var_val</span><span style="color: #797593">[</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #286983">end</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">end</span></span>
<span class="line"></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other eval parts</span></span>
<span class="line"><span style="color: #575279">    </span><span style="color: #286983">elsif</span><span style="color: #575279"> exp</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">==</span><span style="color: #575279"> </span><span style="color: #797593">:</span><span style="color: #286983">define</span></span>
<span class="line"><span style="color: #575279">        _</span><span style="color: #797593">,</span><span style="color: #575279"> var</span><span style="color: #797593">,</span><span style="color: #575279"> value_exp </span><span style="color: #286983">=</span><span style="color: #575279"> exp</span></span>
<span class="line"></span>
<span class="line"><span style="color: #575279">        value </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #B4637A; font-style: italic">eval</span><span style="color: #797593">(</span><span style="color: #575279"> value_exp</span><span style="color: #797593">,</span><span style="color: #575279"> env </span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        env</span><span style="color: #797593">[</span><span style="color: #D7827E">0</span><span style="color: #797593">..</span><span style="color: #286983">-</span><span style="color: #D7827E">1</span><span style="color: #797593">]</span><span style="color: #575279"> </span><span style="color: #286983">=</span><span style="color: #575279"> </span><span style="color: #797593">[[</span><span style="color: #575279">var </span><span style="color: #797593">,</span><span style="color: #575279"> value</span><span style="color: #797593">]]</span><span style="color: #575279"> </span><span style="color: #286983">+</span><span style="color: #575279"> env</span></span>
<span class="line"><span style="color: #797593">    </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> ... other eval parts</span></span>
<span class="line"><span style="color: #286983">end</span><span style="color: #575279"> </span><span style="color: #797593; font-style: italic">#</span><span style="color: #9893A5; font-style: italic"> eval</span></span></code></pre>
</figure>
<p>至此，最重要的lambda部分就已经完成实现了。</p>
<h2 id="racketonruby总结">RacketOnRuby总结</h2>
<p>出于练习目的，实现Racket的一个解析器。从功能完整性和性能考虑，并不适合实际生产中运用。</p>
<p>得益于Racket语法统一简单，实现也相对简单。不像很多别的语言，有大量不同形式的语法。</p>
<ul>
<li>相对于原生Racket，肯定缺少一些功能，但常见的基本都实现了。
<ul>
<li>实现了environment、variable、condition(if)、 lambda、 cons cells、
list、 一些primitive procedures(代数运算，数值比较)。</li>
<li>语法缺少的：注释<em>comment</em>、 quote、 # symbol(字面量类似Ruby
symbol)、 一些derived
expression(可以转化为现有的别的表达式，例如cond用来多个条件判断，可以转化为嵌套的if)</li>
<li>项目中代码是实现有<code>let</code>和<code>letrec</code>，也是derived
expression。<code>(let ([&lt;var&gt; &lt;exp&gt;]) body)</code>其作用就是绑定local
variable，并在其environment执行body部分代码。<code>let</code>可以转为<code>lambda</code>,
<code>letrec</code>可以转为一种特殊形式<code>let</code>。转化方法是直接操作AST，由于Ruby中AST用的Array表现，并不是那么清晰，所以不做本文重点。（相对于metalanguage使用Lisp系语言，Lisp系语言code即data，代码部分也可以操作，即可以直接在程序expression上直接操作）</li>
<li>缺少大量primitive
procedures，语言肯定会有大量自带的函数，不可能一一实现。其中之一就是mutation
list，Racket的默认list是不可变的immutable。如果需要可变的，有专门的操作:<code>mcons</code>，<code>set-mcar!</code>,
<code>set-mcdr!</code>。这一点也是Racket与Scheme不同的一处，Scheme中list是mutation
list。</li>
<li>error
handling不是主要目标，所以几乎没有异常错误处理，所以需要执行的program先要保证正确的。可以DrRacket先执行一遍，尤其括号方面（多或者少，不匹配），IDE可以很明显看出括号范围。</li>
</ul></li>
<li>性能方面，也不是主要目标，没有特别优化。下面指出一些可以改进的地方：
<ul>
<li><code>eval</code>实现，实际上语义分析<em>syntactic
analysis</em>夹杂在执行<em>execution</em>之中，不是有效率的做法。如下阶乘的program，当执行<code>(factorial 5)</code>，递归调用<code>factorial</code>多次，其中<code>if</code>部分每次都需要判断出是<code>if</code>，但执行到<code>(* (factorial (- n 1)) n)))</code>其中<code>(- n 1)</code>和<code>(factorial (- n 1))</code>都需要在<code>eval</code>判断出是方法执行然后再处理。非常重复浪费的做法，需要将analysis分离出来，本文并没涉及，具体实现可以参考SICP<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>第四大章中<em>Separating Syntactic
Analysis from Execution</em>小节部分
<figure class="highlight code-block">
<figcaption>
<span class="language">scheme</span>
</figcaption>
<pre class="shiki rose-pine-dawn" style="background-color: #faf4ed" tabindex="0"><code><span class="line"><span style="color: #575279">    </span><span style="color: #797593">(</span><span style="color: #286983">define</span><span style="color: #575279"> </span><span style="color: #797593">(</span><span style="color: #D7827E">factorial</span><span style="color: #907AA9; font-style: italic"> n</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">        </span><span style="color: #797593">(</span><span style="color: #286983">if</span><span style="color: #575279"> </span><span style="color: #797593">(</span><span style="color: #286983">=</span><span style="color: #575279"> n </span><span style="color: #D7827E">1</span><span style="color: #797593">)</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #D7827E">1</span></span>
<span class="line"><span style="color: #575279">            </span><span style="color: #797593">(</span><span style="color: #286983">*</span><span style="color: #575279"> </span><span style="color: #797593">(</span><span style="color: #575279">factorial </span><span style="color: #797593">(</span><span style="color: #286983">-</span><span style="color: #575279"> n </span><span style="color: #D7827E">1</span><span style="color: #797593">))</span><span style="color: #575279"> n</span><span style="color: #797593">)))</span></span></code></pre>
</figure></li>
<li>缺少<code>TCO</code><em>tail call
optimization</em>，尾递归优化，Lisp和Scheme系的语言program非常依赖与递归调用，TCO非常重要，能省去很多function
call占用的stack空间。</li>
</ul></li>
</ul>
<p>要想了解interpreter如何工作，最好办法就是自己实现一个了，这就是我实现RacketOnRuby以及写本文的目的。
如果需要更深入了解，推荐上文提及SICP以及另外一本书TSPL<a href="#fn4"
class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>，都是有免费阅读的电子版。或者自行搜索，有相当多的资料。</p>
<p>另外文章最开始提及的《黑客与画家》，非编程技术书，也推荐阅读。语言通俗易懂，不涉及技术细节，阅读不费力，非程序员也能读。但其中作者的思想条理清晰，观点深入透彻。另外本书也不光全是关于Lisp，还有一些有趣事情，我印象较深的就是最开始的章节”为什么书呆子不受欢迎”。</p>
<p>{# &gt; The prefixes <code>#b</code>, <code>#o</code>, and
<code>#x</code> specify binary, octal, and hexadecimal interpretation of
digits</p>
<h4
id="implemention-on-racket-environment-using-cons-benifit-sharing-small-part-due-to-immutation">implemention
on Racket environment using cons (benifit sharing small part due to
immutation)</h4>
<p>#}</p>
<!-- toc -->
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p><a
href="https://ruby-doc.org/core-2.4.0/String.html#method-i-split">Ruby
Doc: String.split</a>: If pattern is a String, then its contents are
used as the delimiter when splitting str. If pattern is <strong>a single
space</strong>, str is split on <strong>whitespace</strong>, with
leading whitespace and runs of <strong>contiguous whitespace characters
ignored</strong>.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://ruby-doc.org/core-2.4.0/Enumerable.html#method-i-each_cons">Ruby
Doc Enumerable each_cons(n)</a>: Iterates the given block for each array
of consecutive <n> elements. If no block is given, returns an
enumerator.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><em>Structure and Interpretation of Computer
Programs</em> <a
href="https://mitpress.mit.edu/sicp/full-text/book/book.html">MIT
scheme课程书籍</a>. <a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><em>The Scheme Programming Language</em> <a
href="http://www.scheme.com/tspl4/">http://www.scheme.com/tspl4/</a>. <a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></content><author><name></name></author><category term="programming" /><category term="interpreter" /><category term="racket" /><category term="ruby" /><category term="lambda" /><category term="scheme" /><category term="lisp" /><category term="eval" /><summary type="html"><![CDATA[如果学习Lisp系语言，可能在后期都会实现一个本语言的解释器interpreter来练个手。 我学的是 Lisp(或者说Scheme) 方言之一的Racket，自己当时能写解释器的时候的确感觉不一样。 毕竟之前也接触过很多语言，基本都是学的语言特性feature，和其流行的package使用(比如web框架)。很少接触过语言实现language implemention的知识。 当自己能写出解释器的时候，感觉到一种新的学习语言的体验。 这篇文章努力做到新手友好，只需要有一定编程知识基础(可能只要懂一门语言)即可阅读。 项目github链接：https://github.com/mixflow/RacketOnRuby/]]></summary></entry><entry><title type="html">UE4作品 简易书房</title><link href="https://www.mix-flow.com/works/ue4/2017/02/18/UE4-work-book-room.html" rel="alternate" type="text/html" title="UE4作品 简易书房" /><published>2017-02-18T01:53:21+08:00</published><updated>2017-02-18T01:53:21+08:00</updated><id>https://www.mix-flow.com/works/ue4/2017/02/18/UE4-work-book-room</id><content type="html" xml:base="https://www.mix-flow.com/works/ue4/2017/02/18/UE4-work-book-room.html"><![CDATA[<ul>
<li>制作软件: Unreal Engine 4</li>
<li>建模软件: Blender</li>
</ul>
<p>这个是我初期学习UE4，并尝试做的作品（2016初），是第一个有可以看的东西的UE4作品。<br />
在之前的学习UE4做的东西并不是画面为主，不太适合展示，比如游戏AI。</p>
<figure>
<img src="/images/2016-BookRoom/1.jpg" alt="概览 前厅" />
<figcaption aria-hidden="true">概览 前厅</figcaption>
</figure>
<!-- more -->
<figure>
<img src="/images/2016-BookRoom/2.jpg" alt="前厅 沙发椅" />
<figcaption aria-hidden="true">前厅 沙发椅</figcaption>
</figure>
<figure>
<img src="/images/2016-BookRoom/3.jpg" alt="侧面概览" />
<figcaption aria-hidden="true">侧面概览</figcaption>
</figure>
<figure>
<img src="/images/2016-BookRoom/4.jpg" alt="桌子" />
<figcaption aria-hidden="true">桌子</figcaption>
</figure>
<figure>
<img src="/images/2016-BookRoom/5.jpg" alt="两联窗户" />
<figcaption aria-hidden="true">两联窗户</figcaption>
</figure>
<figure>
<img src="/images/2016-BookRoom/6.jpg" alt="书架&amp;画板" />
<figcaption aria-hidden="true">书架&amp;画板</figcaption>
</figure>
<figure>
<img src="/images/2016-BookRoom/7.jpg" alt="从书房的概览" />
<figcaption aria-hidden="true">从书房的概览</figcaption>
</figure>
<figure>
<img src="/images/2016-BookRoom/8.jpg" alt="楼梯" />
<figcaption aria-hidden="true">楼梯</figcaption>
</figure>]]></content><author><name></name></author><category term="works" /><category term="ue4" /><category term="UE4" /><category term="unreal engine" /><category term="work" /><category term="interior" /><category term="blender" /><category term="PBR" /><category term="3D" /><category term="CG" /><summary type="html"><![CDATA[制作软件: Unreal Engine 4 建模软件: Blender]]></summary></entry></feed>